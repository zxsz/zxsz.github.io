<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zxs的个人主页</title>
  
  <subtitle>go big or go home</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-10-06T08:10:14.103Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>zxs</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>bind+blz+mariadb 构建智能DNS</title>
    <link href="http://yoursite.com/2017/09/25/2017-09-25-dns/"/>
    <id>http://yoursite.com/2017/09/25/2017-09-25-dns/</id>
    <published>2017-09-24T16:00:00.000Z</published>
    <updated>2017-10-06T08:10:14.103Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>最近学了bind和mysql基础,纯属为了练习操作,巩固知识,和理解bind和mysql是如何通过 blz结合的. 智能DNS的原理很简单, 当客户端访问同一个网站域名时,通过bind的view视图功能,匹配不同ip的客户端去查找不同zone下的A记录,解析到理客户端最近的服务器ip地址,以提高网站的访问速度 .这个功能正好符合中国南电信北网通的基本国情.</p><a id="more"></a><h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>bind版本</td><td>BIND 9.11.0-P1</td></tr><tr><td>mariaDB版本</td><td>5.5.57-MariaDB(通用二进制)</td></tr><tr><td>操作系统版本</td><td>CentOS-6.9_86x64 (虚拟机环境)</td></tr></tbody></table><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="http://docs.linuxtone.org/ebooks/CDN/bind-dlz-view2.pdf" target="_blank" rel="external">http://docs.linuxtone.org/ebooks/CDN/bind-dlz-view2.pdf</a></p><p><a href="http://www.jianshu.com/p/1318ef8865ba" target="_blank" rel="external">http://www.jianshu.com/p/1318ef8865ba</a></p><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><h4 id="安装mariaDB"><a href="#安装mariaDB" class="headerlink" title="安装mariaDB"></a>安装mariaDB</h4><p>安装数据库mysql和mariadb其实都一样,也可以直接使用yum安装mysql不过版本较低,这里使用通用二进制安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line">tar xf mariadb-5.5.57-linux-x86_64.tar.gz -C /usr/local/</div><div class="line">cd /usr/local/</div><div class="line">ln -sv mariadb-5.5.57-linux-x86_64/ mysql</div><div class="line">cd mysql/</div><div class="line">groupadd -g 306 -r mysql</div><div class="line">useradd -r -g mysql -s /sbin/nologin mysql</div><div class="line">chown -R root.mysql .</div><div class="line">mkdir /mydata</div><div class="line">chown -R mysql.mysql /mydata</div><div class="line"><span class="meta">#</span> 准备数据库目录,为了更好的扩展性,可以专门创建一个LVM分区挂载到目录下,并格式化为xfs文件系统</div><div class="line"><span class="meta">#</span> 据说mysql跑再xfs文件系统上性能更好,以下过程为在/dev/sdb 上创建lvm 可跳过</div><div class="line">        parted /dev/sdb mklabel msdos</div><div class="line">        parted /dev/sdb mkpart primary 1 1000</div><div class="line">        parted /dev/sdb toggle 1 lvm</div><div class="line">        pvcreate /dev/sdb1</div><div class="line">        vgcreate myvg /dev/sdb1</div><div class="line">        lvcreate -n mylv -L 950M myvg</div><div class="line">        yum install xfsprogs</div><div class="line">        mkfs.xfs /dev/myvg/mylv</div><div class="line">        # 写入/etc/fstable中,可开机挂载</div><div class="line">        mount -a</div><div class="line">./scripts/mysql_install_db  --user=mysql --datadir=/mydata</div><div class="line">mkdir /etc/mydata</div><div class="line">cp support-files/my-huge.cnf /etc/mysql/my.cnf</div><div class="line">cp support-files/mysql.server /etc/init.d/mysqld</div><div class="line">chkconfig --add mysqld</div><div class="line"><span class="meta">#</span> 这里实际已经安装好了,为了易用性需要导出path路径,man文档,lib库,和头文件.</div><div class="line">vim /etc/man.config 添加 MANPATH /usr/local/mysql/man</div><div class="line">echo 'export PATH=/usr/local/mysql/bin:$PATH' &gt; /etc/profile.d/mysql.sh</div><div class="line">. /etc/profile.d/mysql.sh</div><div class="line">echo '/usr/local/mysql/lib' &gt; /etc/ld.so.conf.d/mysql.conf</div><div class="line">ldconfig -v</div><div class="line">ln -sv /usr/local/mysql/include/ /usr/include/mysql</div></pre></td></tr></table></figure><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">vim /etc/mysql/my.cnf</div><div class="line"><span class="meta">#</span> 修改或添加以下内容</div><div class="line">thread_concurrency = 2</div><div class="line">datadir=/mydata</div><div class="line">innodb_file_per_table = on</div><div class="line">skip_name_resolve = on</div></pre></td></tr></table></figure><h4 id="启动mysql"><a href="#启动mysql" class="headerlink" title="启动mysql"></a>启动mysql</h4><p>启动是可能会报错,日志文件不可写,那就手动创建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">service mysqld start</div><div class="line">touch /var/log/mysqld.log</div><div class="line">chmod 640 /var/log/mysqld.log</div><div class="line">chown mysql.mysql /var/log/mysqld.log</div><div class="line"><span class="meta">#</span> 运行mysql安全初始化脚本,这里设定root密码为 123456</div><div class="line">mysql_secure_installation</div></pre></td></tr></table></figure><h4 id="编译安装bind"><a href="#编译安装bind" class="headerlink" title="编译安装bind"></a>编译安装bind</h4><p>安装bind必须要启用blz(Dynamically Loadable Zones) 模块,用于连接mysql的重要组件,而且bind版本貌似要高一点的版本低版本不支持 blz 还需要打补丁</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tar xf bind-9.11.0-P1.tar.gz</div><div class="line">cd bind-9.10.1-P1</div><div class="line">./configure --with-dlz-mysql --prefix=/usr/local/bind --disable-ipv6 --disable-chroot </div><div class="line">make &amp;&amp; make install</div></pre></td></tr></table></figure><p>编译安装bind不怎么费劲,配置有的麻烦,没有任何配置文件,区域文件,rndc也要自己配置,启动脚本也没有,权限什么的也要细心,搞不好服务就起不来</p><h4 id="配置bind工作环境"><a href="#配置bind工作环境" class="headerlink" title="配置bind工作环境"></a>配置bind工作环境</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">useradd -r named -s /sbin/nologin</div><div class="line">mkdir /var/named</div><div class="line">chown root.named /var/named</div><div class="line">chmod 750 /var/named/</div><div class="line"><span class="meta">#</span> 导出man,path,lib,inclue等 ,bind程序lib中都是 *.a的库文件不需要导入</div><div class="line">vim /etc/man.config 添加 MANPATH /usr/local/bind/share/man</div><div class="line">echo 'export PATH=/usr/local/bind/bin:/usr/local/bind/sbin:$PATH' &gt; /etc/profile.d/bind.sh</div><div class="line">. /etc/profile.d/bind.sh</div><div class="line">ln -sv /usr/local/bind/include/ /usr/include/bind</div><div class="line"><span class="meta">#</span> 生成namd.ca文件</div><div class="line">dig -t NS . &gt; /var/named/named.ca</div><div class="line"><span class="meta">#</span> 配置rndc</div><div class="line">rndc-confgen -r /dev/urandom &gt; rndc.conf</div><div class="line">tail -11 rndc.conf &gt;&gt; named.conf</div><div class="line"><span class="meta">#</span> 修改/usr/local/bind/etc目录下文件权限</div><div class="line">chmod 640 .</div><div class="line">chown named.named .</div><div class="line"><span class="meta">#</span> 修改区域目录下文件的权限</div><div class="line">chmod -R 640 /var/named/*</div><div class="line">chown root.named /var/named/*</div></pre></td></tr></table></figure><p>编辑named.conf文件,这里由于是实验环境,先做最简单的配置只需配置options字段和将rndc.conf 的key的配置加入namd.conf文件的末尾,稍后使用dlz配置区域文件,内容如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">options &#123;</div><div class="line">        directory "/var/named";</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="meta">#</span> Use with the following in named.conf, adjusting the allow list as needed:</div><div class="line">key "rndc-key" &#123;</div><div class="line">        algorithm hmac-md5;</div><div class="line">        secret "4ZJscDCbqAawFNdl6Bg2FQ==";</div><div class="line">&#125;;</div><div class="line"></div><div class="line">controls &#123;</div><div class="line">        inet 127.0.0.1 port 953</div><div class="line">                allow &#123; 127.0.0.1; &#125; keys &#123; "rndc-key"; &#125;;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#</span> End of named.conf</div></pre></td></tr></table></figure><p>导入配置文件后第一次启动使用命令方便排错,在前台运行报错提示很详细,基本上都是权限文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">named -u named -f -g -d 3</div></pre></td></tr></table></figure><h4 id="配置启动脚本"><a href="#配置启动脚本" class="headerlink" title="配置启动脚本"></a>配置启动脚本</h4><p>配置启动脚本前</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div><div class="line">112</div><div class="line">113</div><div class="line">114</div><div class="line">115</div><div class="line">116</div><div class="line">117</div><div class="line">118</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> named a network name service.</div><div class="line"><span class="meta">#</span> chkconfig: 345 35 75</div><div class="line"><span class="meta">#</span> description: a name server</div><div class="line"> </div><div class="line">[ -r /etc/rc.d/init.d/functions ] &amp;&amp; . /etc/rc.d/init.d/functions</div><div class="line"> </div><div class="line">Builddir=/usr/local/bind/</div><div class="line">PidFile=/var/run/named/named.pid</div><div class="line">LockFile=/var/lock/subsys/named</div><div class="line">Sbindir=$&#123;Builddir&#125;/sbin</div><div class="line">Configfile=$&#123;Builddir&#125;/etc/named.conf</div><div class="line">CheckConf=$&#123;Builddir&#125;/sbin/named-checkconf</div><div class="line">named=named</div><div class="line"> </div><div class="line">if [ ! -f $&#123;Configfile&#125; ]</div><div class="line">then</div><div class="line">    echo "Can't find named.conf " </div><div class="line">    exit 1 </div><div class="line">fi</div><div class="line"> </div><div class="line">if [ ! -d /var/run/named/ ]  </div><div class="line">then</div><div class="line">    echo "could not open directory '/var/run/named/': Permission denied " </div><div class="line">    exit 1</div><div class="line">elif [ ! -w /var/run/named/ ]</div><div class="line">    then</div><div class="line">        echo "could not open directory '/var/run/named/': Permission denied "</div><div class="line">        exit 1</div><div class="line">fi</div><div class="line"> </div><div class="line"> </div><div class="line">if [ ! -r $&#123;Configfile&#125; ]</div><div class="line">then</div><div class="line">    echo "Error: $&#123;Configfile&#125; is not readfile!"</div><div class="line">    exit 1</div><div class="line">else</div><div class="line">    $CheckConf</div><div class="line">    if [ $? != 0 ]</div><div class="line">    then</div><div class="line">        echo -e "Please check config file in \033[31m$&#123;Configfile&#125; \033[0m!"</div><div class="line">        exit 2</div><div class="line">    fi</div><div class="line">fi</div><div class="line"> </div><div class="line">start() &#123;</div><div class="line">    [ -x $&#123;Builddir&#125;/sbin/$named ] ||   exit 4</div><div class="line">    if [ -f $LockFile ]; then</div><div class="line">        echo -n "$named is already running..."</div><div class="line">        echo_failure</div><div class="line">        echo</div><div class="line">        exit 5</div><div class="line">    fi</div><div class="line">     </div><div class="line">    echo -n "Starting $named: "</div><div class="line">    daemon --pidfile "$PidFile" $&#123;Sbindir&#125;/$named -u named -4 -c $&#123;Configfile&#125;</div><div class="line">    RETVAL=$?</div><div class="line">    echo</div><div class="line">    if [ $RETVAL -eq 0 ]; then</div><div class="line">        touch $LockFile</div><div class="line">        return 0</div><div class="line">    else</div><div class="line">        rm -f $LockFile $PidFile</div><div class="line">        return 1</div><div class="line">    fi</div><div class="line">&#125;</div><div class="line"> </div><div class="line">stop() &#123;</div><div class="line">    if [ ! -f $LockFile ];then</div><div class="line">        echo "$named is not started."</div><div class="line">        echo_failure</div><div class="line">    fi</div><div class="line"> </div><div class="line">    echo -n "Stopping $named: "</div><div class="line">    killproc $named</div><div class="line">    RETVAL=$?</div><div class="line">    echo</div><div class="line">    [ $RETVAL -eq 0 ] &amp;&amp; rm -f $LockFile</div><div class="line">    return 0</div><div class="line">&#125;</div><div class="line"> </div><div class="line">restart() &#123;</div><div class="line">    stop</div><div class="line">    sleep 1</div><div class="line">    start</div><div class="line">&#125;</div><div class="line"> </div><div class="line">reload() &#123;</div><div class="line">    echo -n "Reloading $named: "</div><div class="line">    killproc $named -HUP</div><div class="line">    RETVAL=$?</div><div class="line">    echo</div><div class="line">    return $RETVAL</div><div class="line">&#125;</div><div class="line"> </div><div class="line">status() &#123;</div><div class="line">    if pidof $named &gt; /dev/null &amp;&amp; [ -f $PidFile ]; then</div><div class="line">        echo "$named is running..."</div><div class="line">    else</div><div class="line">        echo "$named is stopped..."</div><div class="line">    fi</div><div class="line">&#125;</div><div class="line"> </div><div class="line">case $1 in</div><div class="line">start)</div><div class="line">    start ;;</div><div class="line">stop) </div><div class="line">    stop ;;</div><div class="line">restart)</div><div class="line">    restart ;;</div><div class="line">reload)</div><div class="line">    reload ;;</div><div class="line">status)</div><div class="line">    status ;;</div><div class="line">*)</div><div class="line">    echo "Usage:named &#123;start|stop|status|reload|restart&#125;"</div><div class="line">    exit 2;;</div><div class="line">esac</div></pre></td></tr></table></figure><h4 id="脚本启动named"><a href="#脚本启动named" class="headerlink" title="脚本启动named"></a>脚本启动named</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir /var/run/named</div><div class="line">chmod +x /etc/init.d/named</div><div class="line">chkconfig --add named</div></pre></td></tr></table></figure><h4 id="创建库和表"><a href="#创建库和表" class="headerlink" title="创建库和表"></a>创建库和表</h4><p>使用下面sql语句创建dns_data数据库和dns_record 表,保存文件导入就行</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">DROP</span> <span class="keyword">DATABASE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> dns_data;</div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> dns_data;</div><div class="line"> <span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> dns_data.dns_records;</div><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> dns_data.dns_records (</div><div class="line"> <span class="keyword">id</span> <span class="built_in">int</span>(<span class="number">10</span>) <span class="keyword">unsigned</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment,</div><div class="line"> zone <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line"> host <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="string">'@'</span>,</div><div class="line"> <span class="keyword">type</span> ENUM (<span class="string">'MX'</span>,<span class="string">'CNAME'</span>,<span class="string">'NS'</span>,<span class="string">'SOA'</span>,<span class="string">'A'</span>,<span class="string">'PTR'</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line"> <span class="keyword">data</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">default</span> <span class="literal">NULL</span>,</div><div class="line"> ttl <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="string">'800'</span>,</div><div class="line"> <span class="keyword">view</span> ENUM (<span class="string">'cnc'</span>,<span class="string">'chinanet'</span>,<span class="string">'any'</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="string">'any'</span>, </div><div class="line"> mx_priority <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">default</span> <span class="literal">NULL</span>,</div><div class="line"> <span class="keyword">refresh</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="string">'3600'</span>,</div><div class="line"> retry <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="string">'3600'</span>,</div><div class="line"> <span class="keyword">expire</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="string">'86400'</span>,</div><div class="line"> <span class="keyword">minimum</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="string">'3600'</span>,</div><div class="line"> <span class="built_in">serial</span> <span class="built_in">bigint</span>(<span class="number">20</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="string">'2017092501'</span>,</div><div class="line"> resp_person <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="string">'admin.zxs.com.'</span>,</div><div class="line"> primary_ns <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">default</span> <span class="string">'ns1.zxs.com.'</span>,</div><div class="line"> PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</div><div class="line"> <span class="keyword">KEY</span> <span class="keyword">type</span> (<span class="keyword">type</span>),</div><div class="line"> <span class="keyword">KEY</span> host (host),</div><div class="line"> <span class="keyword">KEY</span> zone (zone)</div><div class="line">) <span class="keyword">ENGINE</span>=MyISAM AUTO_INCREMENT=<span class="number">1</span> <span class="keyword">DEFAULT</span> <span class="keyword">CHARSET</span>=utf8;</div></pre></td></tr></table></figure><p>表结构如下图:</p><p><img src="http://47.91.157.219/images/mysql.png" alt="dns_records结构"></p><h4 id="导入记录"><a href="#导入记录" class="headerlink" title="导入记录"></a>导入记录</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`dns_records`</span> (<span class="string">`zone`</span>, <span class="string">`host`</span>, <span class="string">`type`</span>, <span class="string">`data`</span>, <span class="string">`ttl`</span>,<span class="string">`mx_priority`</span>, <span class="string">`refresh`</span>, <span class="string">`retry`</span>, <span class="string">`expire`</span>,</div><div class="line"><span class="string">`minimum`</span>, <span class="string">`serial`</span>, <span class="string">`resp_person`</span>, <span class="string">`primary_ns`</span>) <span class="keyword">VALUES</span></div><div class="line">(<span class="string">'zxs.com'</span>, <span class="string">'@'</span>, <span class="string">'SOA'</span>, <span class="string">'ns1.zxs.com.'</span>, <span class="number">10</span>, <span class="literal">NULL</span>, <span class="number">3600</span>, <span class="number">3600</span>, <span class="number">86400</span>, <span class="number">10</span>, <span class="number">2017092501</span>,</div><div class="line"><span class="string">'admin.zxs.com.'</span>, <span class="string">'ns1.zxs.com.'</span>); </div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`dns_records`</span> (<span class="string">`zone`</span>, <span class="string">`host`</span>, <span class="string">`type`</span>, <span class="string">`data`</span>) <span class="keyword">VALUES</span></div><div class="line">(<span class="string">'zxs.com'</span>, <span class="string">'@'</span>, <span class="string">'NS'</span>, <span class="string">'ns1.zxs.com.'</span>);</div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`dns_records`</span> (<span class="string">`zone`</span>, <span class="string">`host`</span>, <span class="string">`type`</span>, <span class="string">`data`</span>) <span class="keyword">VALUES</span></div><div class="line">(<span class="string">'zxs.com'</span>, <span class="string">'ns1'</span>, <span class="string">'A'</span>, <span class="string">'192.168.5.115'</span>);</div><div class="line"></div><div class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="string">`dns_records`</span> (<span class="string">`zone`</span>, <span class="string">`host`</span>, <span class="string">`type`</span>, <span class="string">`data`</span>, <span class="string">`ttl`</span>, <span class="string">`view`</span>) <span class="keyword">VALUES</span></div><div class="line">(<span class="string">'zxs.com'</span>, <span class="string">'www'</span>, <span class="string">'A'</span>, <span class="string">'6.6.6.6'</span>, <span class="number">3600</span>, <span class="string">'cnc'</span>),</div><div class="line">(<span class="string">'zxs.com'</span>, <span class="string">'www'</span>, <span class="string">'A'</span>, <span class="string">'7.7.7.7'</span>, <span class="number">3600</span>, <span class="string">'chinanet'</span>),</div><div class="line">(<span class="string">'zxs.com'</span>, <span class="string">'www'</span>, <span class="string">'A'</span>, <span class="string">'8.8.8.8'</span>, <span class="number">3600</span>, <span class="string">'any'</span>);</div></pre></td></tr></table></figure><p>实验添加的记录为:</p><p>解析域名<code>www.zxs.com</code>  三条A记录 分别是 网通客户端 (cnc) 指向 6.6.6.6  电信客户端(chinanet) 指向 7.7.7.7  其他指向 8.8.8.8</p><p>表数据如下图:</p><p><img src="http://47.91.157.219/images/mysql2.png" alt="dns_records表数据"></p><h4 id="配置dlz连接到数据库"><a href="#配置dlz连接到数据库" class="headerlink" title="配置dlz连接到数据库"></a>配置dlz连接到数据库</h4><p>实验为了测试效果使用的是内网ip代表电信的ip, 和网通的ip,  </p><p>简化起见没有配置根区域,dns不允许递归查询的话也没有必要配置根区域 ,所有的acl 和 view都定义在一个配置文件中</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line">options &#123;</div><div class="line">directory "/var/named";</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="meta">#</span> Use with the following in named.conf, adjusting the allow list as needed:</div><div class="line">key "rndc-key" &#123;</div><div class="line">algorithm hmac-md5;</div><div class="line">secret "4ZJscDCbqAawFNdl6Bg2FQ==";</div><div class="line">&#125;;</div><div class="line"></div><div class="line"></div><div class="line">controls &#123;</div><div class="line"> inet 127.0.0.1 port 953</div><div class="line"> allow &#123; 127.0.0.1; &#125; keys &#123; "rndc-key"; &#125;;</div><div class="line">&#125;;</div><div class="line"><span class="meta">#</span> End of named.conf</div><div class="line"></div><div class="line">acl cnc &#123;</div><div class="line">172.18.0.0/16;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">acl chinanet &#123;</div><div class="line">192.168.5.0/24;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">view cnc_view &#123;</div><div class="line">match-clients &#123; cnc; &#125;;</div><div class="line">dlz "Mysql zone" &#123;</div><div class="line">               database        "mysql</div><div class="line">               &#123;host=localhost dbname=dns_data ssl=false port=3306 user=root pass=123456&#125;</div><div class="line">               &#123;select zone from dns_records where zone='$zone$'&#125;</div><div class="line">               &#123;select ttl, type, mx_priority, case when lower(type)='txt' then concat('\"', data, '\"') when lower(type) = 'soa' then concat_ws(' ', data, resp_person, serial, refresh, retry, expire, minimum) else data end from dns_records where zone = '$zone$' and host = '$record$' and view='cnc'&#125;"; </div><div class="line">        &#125;;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">view chinanet_view &#123;</div><div class="line">match-clients &#123; chinanet; &#125;;</div><div class="line">dlz "Mysql zone" &#123;</div><div class="line">               database        "mysql</div><div class="line">               &#123;host=localhost dbname=dns_data ssl=false port=3306 user=root pass=123456&#125;</div><div class="line">               &#123;select zone from dns_records where zone='$zone$'&#125;</div><div class="line">               &#123;select ttl, type, mx_priority, case when lower(type)='txt' then concat('\"', data, '\"') when lower(type) = 'soa' then concat_ws(' ', data, resp_person, serial, refresh, retry, expire, minimum) else data end from dns_records where zone = '$zone$' and host = '$record$' and view='chinanet'&#125;"; </div><div class="line">        &#125;;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><h4 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h4><p>为了内网的ip段<code>172.18.0.0/16</code>  <code>192.168.5.0/24</code>  都能指定这个dns服务器解析,本机配置了两个ip <code>192.168.5.115</code>  和 <code>172.18.5.115</code>  ,使用不同网段机器测试效果如下</p><p><img src="http://47.91.157.219/images/mysql3.png" alt="测试1"></p><p><img src="http://47.91.157.219/images/mysql4.png" alt="测试2"></p><h3 id="如何获得电信联通ip地址列表"><a href="#如何获得电信联通ip地址列表" class="headerlink" title="如何获得电信联通ip地址列表"></a>如何获得电信联通ip地址列表</h3><h4 id="方法一-网站下载"><a href="#方法一-网站下载" class="headerlink" title="方法一: 网站下载"></a>方法一: 网站下载</h4><p>​    有个网站叫 <a href="https://ispip.clang.cn/" target="_blank" rel="external">苍狼山庄</a> 每日更新</p><h4 id="方法二-whois程序查询"><a href="#方法二-whois程序查询" class="headerlink" title="方法二: whois程序查询"></a>方法二: whois程序查询</h4><p>centos yum源下就有whois工具, 也可以上apnic 亚太互联网络信息中心网站上下载v3版的最新工具来编译安装</p><p><img src="http://47.91.157.219/images/apnic.png" alt="apnic"></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">wget http://ftp.apnic.net/apnic/dbase/tools/ripe-dbase-client-v3.tar.gz</div><div class="line">tar xzvf ripe-dbase-client-v3.tar.gz</div><div class="line">cd whois-3.1</div><div class="line">./configure</div><div class="line">make</div></pre></td></tr></table></figure><h4 id="whois使用用法"><a href="#whois使用用法" class="headerlink" title="whois使用用法"></a>whois使用用法</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">./whois3 -h whois.apnic.net -l -i mb MAINT-CNCGROUP &gt; /tmp/cnc</div><div class="line">./whois3 -h whois.apnic.net -l -i mb MAINT-CHINANET &gt; /tmp/chinanet</div><div class="line">./whois3 -h whois.apnic.net -l -i mb MAINT-CN-CRTC &gt; /tmp/crtc</div><div class="line">./whois3 -h whois.apnic.net -l -i mb MAINT-CN-CMCC &gt; /tmp/cmcc</div></pre></td></tr></table></figure><p>上面查询出来的内容,很详细,包括电话号码,地址定位到某条街,如果只想获取acl列表,需要用 文本三剑客了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">./whois3 -h whois.apnic.net -l -i mb MAINT-CNCGROUP | grep "descr" | grep "Reverse" | awk -F "for" '&#123;if ($2!="") print $2&#125;'| sort -n | awk 'BEGIN&#123;print "acl \"CNC\" '&#123;'"&#125;&#123;print $1";"&#125;END&#123;print "'&#125;';"&#125;' &gt; /root/cnc_acl.conf</div><div class="line"></div><div class="line">./whois3 -h whois.apnic.net -l -i mb MAINT-CHINANET | grep "descr" | grep "Reverse" | awk -F "for" '&#123;if ($2!="") print $2&#125;'| sort -n | awk 'BEGIN&#123;print "acl \"CHINANET\" '&#123;'"&#125;&#123;print $1";"&#125;END&#123;print "'&#125;';"&#125;' &gt; /root/chinanet_acl.conf</div><div class="line"></div><div class="line">./whois3 -h whois.apnic.net -l -i mb MAINT-CN-CRTC | grep "descr" | grep "Reverse" | awk -F "for" '&#123;if ($2!="") print $2&#125;'| sort -n | awk 'BEGIN&#123;print "acl \"CRTC\" '&#123;'"&#125;&#123;print $1";"&#125;END&#123;print "'&#125;';"&#125;' &gt; /root/crtc_acl.conf</div><div class="line"></div><div class="line">./whois3 -h whois.apnic.net -l -i mb MAINT-CN-CMCC | grep "descr" | grep "Reverse" | awk -F "for" '&#123;if ($2!="") print $2&#125;'| sort -n | awk 'BEGIN&#123;print "acl \"CMCC\" '&#123;'"&#125;&#123;print $1";"&#125;END&#123;print "'&#125;';"&#125;' &gt; /root/cmcc_acl.conf</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;最近学了bind和mysql基础,纯属为了练习操作,巩固知识,和理解bind和mysql是如何通过 blz结合的. 智能DNS的原理很简单, 当客户端访问同一个网站域名时,通过bind的view视图功能,匹配不同ip的客户端去查找不同zone下的A记录,解析到理客户端最近的服务器ip地址,以提高网站的访问速度 .这个功能正好符合中国南电信北网通的基本国情.&lt;/p&gt;
    
    </summary>
    
      <category term="服务器架设" scheme="http://yoursite.com/categories/%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%9E%B6%E8%AE%BE/"/>
    
    
      <category term="DNS" scheme="http://yoursite.com/tags/DNS/"/>
    
  </entry>
  
  <entry>
    <title>cobbler</title>
    <link href="http://yoursite.com/2017/09/18/2017-09-18-cobbler/"/>
    <id>http://yoursite.com/2017/09/18/2017-09-18-cobbler/</id>
    <published>2017-09-17T16:00:00.000Z</published>
    <updated>2017-10-06T08:10:14.101Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Cobbler简介"><a href="#Cobbler简介" class="headerlink" title="Cobbler简介"></a>Cobbler简介</h3><p>简单理解 Cobbler就是 DHCP服务器 + TFTP服务器 + yum源服务器(httpd文件传输) 的综合管理平台, 支持众多的发行版：Red Hat、Fedora、CentOS、Debian、Ubuntu 和 SuSE .<br>下面演示的 centos6.9 系统下安装部署 Cobbler</p><a id="more"></a><h3 id="安装cobbler"><a href="#安装cobbler" class="headerlink" title="安装cobbler"></a>安装cobbler</h3><blockquote><p>环境准备</p></blockquote><p>cobbler 软件包在 epel 源里没运行下面命令安装 </p><p>关闭<code>selinux</code> 和 <code>iptables</code> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">yum install -y epel-release.noarch                 # 安装epel源</div><div class="line">service iptables stop</div><div class="line">chkconfig iptables off</div><div class="line">setenforce 0</div><div class="line">sed -i '/^SELINUX=/c\SELINUX=disabled' /etc/selinux/config</div></pre></td></tr></table></figure><blockquote><p>安装软件包</p></blockquote><p>cobbler 软件安装会根据依赖关系,安装一些的软件包(httpd,tftp等) , 但 dhcp 不会依赖安装,稍后单独安装. 个人习惯dhcp服务单独管理,不使用cobbler管理,方便排错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">yum install -y cobbler               # 安装cobbler</div><div class="line">chkconfig httpd on               </div><div class="line">chkconfig cobblerd on</div><div class="line">service httpd start</div><div class="line">service cobblerd start </div><div class="line">cobbler check                        # 检查cobbler配置,提供一个配置向导</div></pre></td></tr></table></figure><p>注意: 运行 <code>cobbler check</code> 之前需要启动<code>httpd</code> 启动<code>cobblerd</code>  ,否则会报错 ,正常结果显示如下图</p><p><img src="http://47.91.157.219/images/cob1.png" alt="check"></p><h3 id="配置cobbler"><a href="#配置cobbler" class="headerlink" title="配置cobbler"></a>配置cobbler</h3><blockquote><p>根据 cobbler check 需要修复的项,有一下几种:</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 问题1:编辑/etc/cobbler/settings 文件，找到 server 选项，修改为本机IP即可</div><div class="line">sed -i '/^server:/c\server: 192.168.5.100' /etc/cobbler/settings</div><div class="line"><span class="meta">#</span> 问题2:编辑/etc/cobbler/settings 文件，找到 next_server 选项，修改为本机IP即可</div><div class="line">sed -i '/^next_server:/c\next_server: 192.168.5.100' /etc/cobbler/settings</div><div class="line"><span class="meta">#</span> 问题3:编辑/etc/xinetd.d/tftp 文件, 将文件中的disable字段的配置由yes改为no</div><div class="line">chkconfig xinetd on</div><div class="line">service xinetd start</div><div class="line">chkconfig  tftp on</div><div class="line"><span class="meta">#</span> 问题4: 为系统准备 pxe loader程序，</div><div class="line"><span class="meta">#</span> 问题4方法一:其实就是复制pxe引导文件到对应目录下</div><div class="line">cp /usr/share/syslinux/&#123;pxelinux.0,menuc32&#125; /var/lib/cobbler/loaders</div><div class="line"><span class="meta">#</span> 问题4方法二:运行命令,需要能上外网</div><div class="line">cobbler get-loaders</div><div class="line"><span class="meta">#</span> 问题5,6:安装 rsync 设置开机自启</div><div class="line">yum install rsync</div><div class="line">chkconfig rsync on</div><div class="line"><span class="meta">#</span> 问题7: 用与安装Debian系的系统,不需要可以忽略</div><div class="line"><span class="meta">#</span> 问题8: 提示 ksvalidator 命令没有,安装 pykickstart,用来检查ks.cfg 文件语法的</div><div class="line">yum install  pykickstart</div><div class="line"><span class="meta">#</span> 问题9: 设置强密码,也就是自动化系统安装后的密码</div><div class="line"><span class="meta">#</span> 问题9: 第一步生成密码(加密后的)</div><div class="line">openssl passwd -1 -salt 'abc' '123456'</div><div class="line"><span class="meta">$</span>1$abc$mJPQCTATLDV5aNzcHMYLr/    # 生成的密码</div><div class="line"><span class="meta">#</span> 问题9: 第二步,修改cobbler settings配置文件 </div><div class="line">vim /etc/cobbler/settings</div><div class="line">default_password_crypted: "$1$abc$mJPQCTATLDV5aNzcHMYLr/"</div><div class="line"><span class="meta">#</span> 问题10: 直接忽略</div><div class="line">cobbler sync</div><div class="line">service cobblerd restart</div><div class="line">cobbler check</div></pre></td></tr></table></figure><p>使用 <code>cobbler check</code> 和 <code>cobbler sync</code>  直到问题修复好,有的非必须, 有的查看已经改好了仍然提示有错 ,例如: 提示 <code>selinux</code> 没有禁用 , 这样也可以忽略不管</p><h3 id="安装配置DHCP"><a href="#安装配置DHCP" class="headerlink" title="安装配置DHCP"></a>安装配置DHCP</h3><p>dhcp可以 交给Cobbler 管理,也可以自己独立管理, dhcp配置文件有误,会导致dhcpd服务无法启动, 如果是cobbler 管理可能导致 cobbler也无法启动. 独立管理方便排错</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">[root@client100 ~]# \cp /usr/share/doc/dhcp*/dhcpd.conf.example dhcpd.conf</div><div class="line">[root@client100 xinetd.d]# grep -v "^#" /etc/dhcp/dhcpd.conf</div><div class="line"></div><div class="line">option domain-name "zxs.com";                       </div><div class="line">option domain-name-servers 114.114.114.114;</div><div class="line">default-lease-time 86400;</div><div class="line">max-lease-time 86400;</div><div class="line">log-facility local7;</div><div class="line"></div><div class="line">subnet 192.168.5.0 netmask 255.255.255.0 &#123;</div><div class="line">  range 192.168.5.1 192.168.5.99;</div><div class="line">  filename "pxelinux.0";</div><div class="line">  next-server 192.168.5.100;</div><div class="line">&#125;</div><div class="line"></div><div class="line">[root@client100 ~]# service dhcpd start</div><div class="line">[root@client100 ~]# chkconfig dhcpd on</div></pre></td></tr></table></figure><p>注意 dhcp配置文件每行末尾的分号,容易忘掉</p><h3 id="导入镜像-distro"><a href="#导入镜像-distro" class="headerlink" title="导入镜像 distro"></a>导入镜像 distro</h3><p>cobbler 导入镜像其实就是复制镜像的文件到 <code>/var/www/cobbler/ks_mirror</code> , </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 有光盘挂载光盘没有光盘使用 -o loop 挂载iso文件</div><div class="line">mount /dev/cdrom  /media/</div><div class="line">cobbler import --name=centos6.9-x86_64 --path=/media</div><div class="line"><span class="meta">#</span> 列出发行版distro</div><div class="line">cobbler distro list</div><div class="line"><span class="meta">#</span> 列出各种发行版的不同安装方式, 也就是网卡启动后的菜单界面</div><div class="line">cobbler profile list</div></pre></td></tr></table></figure><blockquote><p>说明</p></blockquote><ul><li><p>copy完成后,实际上Cobbler 服务器已经搭建好了,只不过只有一个菜单选项(profile) 一个发行版本(distro)</p></li><li><p>这个菜单选项是cobbler 自己自动生成的 菜单文件位置为 <code>/var/lib/tftpboot/pxelinux.cfg/default</code>  一般不需要动</p></li><li><p>镜像文件复制在 <code>/var/www/cobbler/ks_mirror</code> 目录下 可以访问 <code>http://192.168.5.100/cobbler</code> 查看目录结构,就是个镜像站</p></li><li><p>这个默认的安装方式是最小化安装,使用的是 目录  <code>/var/lib/cobbler/kickstarts/</code>  下的</p><p><code>sample_end.ks</code> 文件</p></li></ul><h3 id="导入ks-cfg文件"><a href="#导入ks-cfg文件" class="headerlink" title="导入ks.cfg文件"></a>导入ks.cfg文件</h3><blockquote><p>语法为</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cobbler profile add --name=&lt;菜单上的条目&gt; --distro=&lt;发行版&gt; --kickstart=&lt;文件路径&gt;  # 增加ks.cfg</div><div class="line">cobbler profile edit --name=&lt;菜单上的条目&gt; --kickstart=&lt;文件路径&gt;      # 修改ks.cfg</div><div class="line">cobbler profile remove --name=&lt;菜单上的条目&gt;</div></pre></td></tr></table></figure><p>说明: </p><ul><li>自定义ks文件,需要先将 ks.cfg 文件复制到对应目录 <code>/etc/lib/cobbler/kickstarts</code> 下</li><li>增加和修改ks文件的命令注意区别  修改不需要指定 <code>--distro</code>  因为 <code>--name</code> 指定的profile 已经存在且自己知道之前是与那个发行版 (distro) 绑定的</li><li>修改或增加后要运行 <code>cobbler sync</code> 同步 和重启服务</li></ul><blockquote><p>操作过程如下</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cobbler profile add --name=centos6-test --distro=centos6.9-x86_64 --kickstart=/var/lib/cobbler/kickstart/centos6-test-ks.cfg</div><div class="line">cobbler sync</div><div class="line">service cobblerd restart</div></pre></td></tr></table></figure><p><img src="http://47.91.157.219/images/cob2.png" alt="启动菜单"></p><h3 id="自定义ks-cfg文件"><a href="#自定义ks-cfg文件" class="headerlink" title="自定义ks.cfg文件"></a>自定义ks.cfg文件</h3><p>ks.cfg文件制作方法</p><ul><li>本机安装的 <code>ananaconda-ks.cfg</code> 稍作修改,</li><li>或者使用 <code>system-congif-kickstart</code> 图形界面软件自行制作, </li><li>复制 cobbler 中默认ks.cfg的修改 路径为 <code>/var/lib/cobbler/kickstarts/sample_end.ks</code></li><li>完成后使用 <code>ksvalidator centos6-test-ks.cfg</code>  检查文件语法</li></ul><blockquote><p>centos6.9 ks.cfg 参考文件 </p></blockquote><p>以下中文注释需要删除,可能导致不可用, 且要做相应修改 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line">firewall --disabled</div><div class="line">install</div><div class="line"><span class="meta">#</span> url需要修改可以用cobbler里内置的变量$tree , 可以直接指定路径</div><div class="line">url --url=$tree</div><div class="line"><span class="meta">#</span> 安装后的密码可以使用cobbler配置文件里的变量 $default_password_crypted 也可手动生成</div><div class="line">rootpw --iscrypted $default_password_crypted</div><div class="line">auth  --useshadow  --passalgo=sha512</div><div class="line"><span class="meta">#</span> 使用文本安装</div><div class="line">text</div><div class="line">firstboot --disable</div><div class="line">keyboard us</div><div class="line">lang en_US</div><div class="line">selinux --disabled</div><div class="line"><span class="meta">#</span> 跳过图形</div><div class="line">skipx</div><div class="line">logging --level=info</div><div class="line">reboot</div><div class="line">timezone  Asia/Shanghai</div><div class="line">network  --bootproto=dhcp --device=eth0 --onboot=on</div><div class="line">bootloader --location=mbr</div><div class="line">zerombr</div><div class="line">clearpart --all --initlabel </div><div class="line">part /boot --fstype="ext4" --ondisk=sda --size=300</div><div class="line">part / --fstype="ext4" --ondisk=sda --size=10240</div><div class="line">part /usr --fstype="ext4" --grow --ondisk=sda --size=1</div><div class="line">part swap --fstype="swap" --ondisk=sda --size=1024</div><div class="line"><span class="meta">#</span> 注意安装后脚本定义,定义在安装包前面</div><div class="line"><span class="meta">%</span>post</div><div class="line"><span class="meta">#</span> 导入公钥</div><div class="line">[ -d /root/.ssh ] || mkdir /root/.ssh</div><div class="line">cat &gt;&gt; /root/.ssh/authorzied_keys &lt;&lt; EOF</div><div class="line">ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEA0JO+fs+MtFZYnTTQR7t43ApwzU2H6YPTdTdjfNCUTqmHrO0gAbRe7c+DuesntZb31pmW2wHuB8KyU3i1IFYKDB7ccyvqpfOjfWFKKW34/qpdLWoJ0NlnlgFkmySVX+YsPX0FbxY3yEFNiLXSI95h6U12h0TUPkUxrvZuZZgWIqxNQhu3rOr0nT8jhxfyOnfXxM2+xNVoVAqq+C0zJfYsY0C41IjMFCavSMeKA/OBmgsU4Vg3OQoMx7hDXPB01sRWrDvUp6fea8knnY3QG0imI0K5/T7bRevY7s+Gq11twam9+WPzjXIoKnqMSX785WhqMxEPns8mkxCNrbmIsdTqyQ==</div><div class="line">EOF</div><div class="line"><span class="meta">#</span> 设定主机名</div><div class="line">ClientName=`ifconfig eth0 | awk '/inet addr:/&#123;print $2&#125;' | awk -F. '&#123;print $NF&#125;'`</div><div class="line">sed -i "s@HOSTNAME=.*@HOSTNAME=client$ClientName.zxs.com@g" /etc/sysconfig/network</div><div class="line"><span class="meta">%</span>end</div><div class="line"></div><div class="line"><span class="meta">#</span> 定义安装软件包</div><div class="line"><span class="meta">%</span>packages</div><div class="line">@base</div><div class="line">@compat-libraries</div><div class="line">@debugging</div><div class="line">@development</div><div class="line">@server-platform-devel</div><div class="line"></div><div class="line"><span class="meta">%</span>end</div></pre></td></tr></table></figure><h3 id="cobbler-目录作用总结"><a href="#cobbler-目录作用总结" class="headerlink" title="cobbler 目录作用总结"></a>cobbler 目录作用总结</h3><blockquote><p>数据目录</p></blockquote><p><code>/var/lib/cobbler/config</code>  :用于存放distros，system，profiles 等信息配置文件</p><p><code>/var/lib/cobbler/triggers</code> : 用于存放用户定义的cobbler命令</p><p><code>/var/lib/cobbler/kickstart</code> : 默认存放kickstart文件</p><p><code>/var/lib/cobbler/loaders</code> : 存放各种引导程序</p><blockquote><p>镜像目录</p></blockquote><p><code>/var/www/cobbler/ks_mirror/</code>  :导入的发行版系统的所有数据目录,</p><p><code>/var/www/cobbler/images</code>  :导入发行版的kernel和initrd镜像用于远程网络启动</p><p><code>/var/www/cobbler/repo_mirror/</code>  : yum 仓库存储目录</p><blockquote><p>日志文件</p></blockquote><p><code>/var/log/cobbler/installing</code>  :客户端的安装日志</p><p><code>/var/log/cobbler/cobbler.log</code>  :cobbler日志</p><h3 id="cobbler-配置文件总结"><a href="#cobbler-配置文件总结" class="headerlink" title="cobbler 配置文件总结"></a>cobbler 配置文件总结</h3><blockquote><p>配置文件目录 /etc/cobbler</p></blockquote><ul><li><code>/etc/cobbler/settings</code>  : cobbler 主配置文件</li><li><code>/etc/cobbler/iso/</code> : iso模板配置文件</li><li><code>/etc/cobbler/pxe</code> : pxe模板文件</li><li><code>/etc/cobbler/power</code> : 电源配置文件</li><li><code>/etc/cobbler/user.conf</code> : web服务授权配置文件</li><li><code>/etc/cobbler/users.digest</code> : web访问的用户名密码配置文件</li><li><code>/etc/cobbler/dhcp.template</code>  : dhcp服务器的的配置末班</li><li><code>/etc/cobbler/dnsmasq.template</code>  : dns服务器的配置模板</li><li><code>/etc/cobbler/tftpd.template</code> : tftp服务的配置模板</li><li><code>/etc/cobbler/modules.conf</code>  : 模块的配置文件</li></ul><h3 id="安装web管理界面"><a href="#安装web管理界面" class="headerlink" title="安装web管理界面"></a>安装web管理界面</h3><p>web用户认证的方式由多种,这里采用系统默认的认证配置 文件在 <code>/etc/cobbler/modules.conf</code> 中</p><p>module = authn_configfile  定义</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@client100 ~]# yum install cobbler-web                 </div><div class="line">[root@client100 ~]# htdigest -c /etc/cobbler/users.digest Cobbler &lt;用户名&gt;</div><div class="line"><span class="meta">#</span> 上面的命令 -c 表示创建认证文件 Cobbler 是关键字, 如果创建多个用户管理无需使用 -c 选项</div><div class="line"><span class="meta">#</span> htdigest 是由 httpd-tools 软件包提供</div><div class="line">[root@client100 ~]# service httpd restart </div><div class="line">[root@client100 ~]# service cobblerd restart</div></pre></td></tr></table></figure><p>重启后使用 <code>https://192.168.5.100/cobbler_web</code></p><blockquote><p>挂载centos7 光盘后在web下导入镜像 </p></blockquote><p><img src="http://47.91.157.219/images/cob.gif" alt="导入镜像"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Cobbler简介&quot;&gt;&lt;a href=&quot;#Cobbler简介&quot; class=&quot;headerlink&quot; title=&quot;Cobbler简介&quot;&gt;&lt;/a&gt;Cobbler简介&lt;/h3&gt;&lt;p&gt;简单理解 Cobbler就是 DHCP服务器 + TFTP服务器 + yum源服务器(httpd文件传输) 的综合管理平台, 支持众多的发行版：Red Hat、Fedora、CentOS、Debian、Ubuntu 和 SuSE .&lt;br&gt;下面演示的 centos6.9 系统下安装部署 Cobbler&lt;/p&gt;
    
    </summary>
    
      <category term="自动化运维" scheme="http://yoursite.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="pxe" scheme="http://yoursite.com/tags/pxe/"/>
    
      <category term="kickstart" scheme="http://yoursite.com/tags/kickstart/"/>
    
  </entry>
  
  <entry>
    <title>sudo介绍</title>
    <link href="http://yoursite.com/2017/09/14/2017-09-14-sudo/"/>
    <id>http://yoursite.com/2017/09/14/2017-09-14-sudo/</id>
    <published>2017-09-13T16:00:00.000Z</published>
    <updated>2017-10-06T08:10:14.098Z</updated>
    
    <content type="html"><![CDATA[<h3 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h3><p>root 用户再linux系统中权限太高,为了防止误操作,一般给一些普通用户一些权限,但是有些操作还是需要管理员权限,这时候就要<code>sudo</code> 命令了, 例如普通用户无法添加用户,这时候就可以用利用sodo配置文件,授予特定用户 <code>useadd</code> 命令的权限.</p><a id="more"></a><h3 id="sudo相关文件"><a href="#sudo相关文件" class="headerlink" title="sudo相关文件"></a>sudo相关文件</h3><p>rpm -ql sudo 查看包提供的所有文件,</p><ul><li>配置文件路径 <code>/etc/sudoers</code>  <code>/etc/sudoers.d/*</code>  linux 的配置文件风格大家都懂的. /etc/sudoers 文件只读,不建议修改此文件</li><li>时间戳 <code>/var/db/sudo</code>  sudo 有检查的机制,<code>sudo</code>成功后多长时间默认不用再次输入密码,默认间隔为 5min ,  就是基于此时间戳数据库</li><li>日志文件与权限有关都记录在 <code>/var/log/secure</code></li></ul><h4 id="sudo配置文件的语法"><a href="#sudo配置文件的语法" class="headerlink" title="sudo配置文件的语法"></a>sudo配置文件的语法</h4><p>关于语法和规则有能力请 <code>man 5 sudoers</code> 没有比这个更详细和权威的</p><blockquote><p>配置文件支持通配符 glob机制,注意与正则表达式的区别</p></blockquote><p><code>?</code> : 单个字符 <code>*</code> :任意长度字符 <code>[a-z]</code> 任意其中一个字母等</p><blockquote><p>授权的规则</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">user   host=(runas) command</div></pre></td></tr></table></figure><p>表示: 用户可以通过那些主句以什么用户的身份 运行那些命令</p><blockquote><p>例如 </p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tom  172.18.0.0/16=(jerry) useradd</div></pre></td></tr></table></figure><h3 id="定义别名"><a href="#定义别名" class="headerlink" title="定义别名"></a>定义别名</h3><p>在有的场景下,需用同时授予一大波用户,或者授予用户一大波命令,这一条语句,看起来就会非常难看而且不利于维护,这时候系统为我们,提供了别名规则,</p><h4 id="别名类型"><a href="#别名类型" class="headerlink" title="别名类型"></a>别名类型</h4><ul><li>User_Alias</li><li>Runas_Alias</li><li>Host_Alias</li><li>Cmnd_Alias</li></ul><h4 id="别名定义规范"><a href="#别名定义规范" class="headerlink" title="别名定义规范"></a>别名定义规范</h4><p>必须全部以大写数字或下划线,而且只能用大写字母开头</p><blockquote><p>实例</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">User_Alias SYSADMIN=tom,jerry,%admins               # admins是组名,需要用户 %表示</div><div class="line">User_Alias NETADMIN=natesha,serena</div><div class="line">Host_Alias INNET=magedu.com,172.18.0.0/16,172.16.5.100</div><div class="line">Runas_Alias OPT=root,tom</div><div class="line">Cmnd_Alias SYSCMD=/bin/chown,/bin/chmod</div><div class="line">Cmnd_Alias NETCMD=/sbin/ip,/sbin/ifconfig</div><div class="line"></div><div class="line">SYSADMIN INNET=(OPT) SYSCMD             </div><div class="line">NETADMIT INNET=(ALL) NOPASSWD:NETCMD</div></pre></td></tr></table></figure><p>分析 : 以上机制类似,赋值变量,引用变量的方式 . <code>ALL</code> 也相对与别名代表所有 <code>NOPASSWD</code> 表示sudo命令运行是不需要输入密码验证 </p><h3 id="授权实例"><a href="#授权实例" class="headerlink" title="授权实例"></a>授权实例</h3><blockquote><p>授予用户挂载的权限</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root: ~]# useradd tom</div><div class="line">[root: ~]# echo "tom ALL=(ALL) /bin/mount /dev/cdrom /media/" &gt;&gt; /etc/sudoers.d/tom</div><div class="line">[root: ~]# visudo -c</div><div class="line">/etc/sudoers: parsed OK</div><div class="line">/etc/sudoers.d/tom: bad permissions, should be mode 0440</div><div class="line">[root: ~]# su - tom</div><div class="line">&lt;tom: ~&gt;$ sudo mount /dev/cdrom /media</div><div class="line">[sudo] password for tom: </div><div class="line">Sorry, user tom is not allowed to execute '/bin/mount /dev/cdrom /media' as root on localhost.localdomain.</div></pre></td></tr></table></figure><blockquote><p>错误分析</p></blockquote><p>sudo授权看似简单,实际操作却有很多问题,需要注意的问题有一下几点</p><ul><li>通常便于管理一般都是在 <code>/etc/sudoers.d/</code> 的目录下创建文件(文件名无要求,为了管理最好见名知意)</li><li>授权后习惯使用 <code>visudo -c</code> 检查语法, 上面操作显示语法没有问题,显示文件权限有问题,因为sudo 文件和系统的权限相关,不能运行其他用户访问查看,而且系统提示权限必须是 400</li><li>最后挂载失败显示没有这个规则,不是因为之前权限的问题而是应为 规则是 <code>/media</code> 而用户使用的是 <code>/media/</code></li><li>授权所有命令都应该写绝对路径</li></ul><blockquote><p>授予用户<code>passwd</code> 改名密码命令</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tom ALL=(ALL) /bin/passwd</div></pre></td></tr></table></figure><p>注意: 类似这种敏感的操作程序一定要小心, 这种写法表示只要包含这些关键此即可授权,后面可以跟任意字符串,tom用户完全可以后面跟 root 直接改掉root 从而提权</p><p>正确的做法应该排除掉root 字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tom ALL=(ALL) /bin/passwd,!/bin/passwd root</div></pre></td></tr></table></figure><blockquote><p>授予 <code>cat</code>   命令权限</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tom ALL=(ALL) /bin/cat /var/log/messages*</div></pre></td></tr></table></figure><p>注意 : 在授予用户权限一定要注意通配符 <code>?</code> <code>*</code> , 上面一条命令具有一定的危险性, tom 用户可以在后面跟上空格后跟上任意文件查看到敏感文件的信息例如:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo cat /var/log/messages /etc/shadow</div></pre></td></tr></table></figure><p>排除此类的写法,特点是中间不能有空格, 写法为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">tom  ALL=(root) /bin/cat /var/log/messages*, !/bin/cat /var/log/messages* *</div></pre></td></tr></table></figure><h3 id="sudo命令工具使用"><a href="#sudo命令工具使用" class="headerlink" title="sudo命令工具使用"></a>sudo命令工具使用</h3><blockquote><p>语法</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo [ option ] COMMAND</div></pre></td></tr></table></figure><blockquote><p>选项</p></blockquote><p><code>-l</code> :列出被授权的命令列表</p><p><code>-u</code> user :授权以那个用户的身份执行,缺省是root ,如果授权列表中的runas不是root ,要指定此选项</p><p><code>-v</code> :延长密码有效期5分钟,5分钟内sudo 命令不需要密码</p><p><code>-V</code>  : 显示版本信息,root 用户运行可获得非常详细的信息</p><p><code>-k</code> : 清除密码的有效期,强制下次运行密码要输入密码.</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;sudo&quot;&gt;&lt;a href=&quot;#sudo&quot; class=&quot;headerlink&quot; title=&quot;sudo&quot;&gt;&lt;/a&gt;sudo&lt;/h3&gt;&lt;p&gt;root 用户再linux系统中权限太高,为了防止误操作,一般给一些普通用户一些权限,但是有些操作还是需要管理员权限,这时候就要&lt;code&gt;sudo&lt;/code&gt; 命令了, 例如普通用户无法添加用户,这时候就可以用利用sodo配置文件,授予特定用户 &lt;code&gt;useadd&lt;/code&gt; 命令的权限.&lt;/p&gt;
    
    </summary>
    
      <category term="linux基础" scheme="http://yoursite.com/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="sudo" scheme="http://yoursite.com/tags/sudo/"/>
    
  </entry>
  
  <entry>
    <title>ssh隧道技术</title>
    <link href="http://yoursite.com/2017/09/14/2017-09-14-ssh_tunnel/"/>
    <id>http://yoursite.com/2017/09/14/2017-09-14-ssh_tunnel/</id>
    <published>2017-09-13T16:00:00.000Z</published>
    <updated>2017-10-06T08:13:47.224Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ssh隧道"><a href="#ssh隧道" class="headerlink" title="ssh隧道"></a>ssh隧道</h3><p>ssh通常用于加密的远程登陆,其他ssh功能非常强大,其中一个就是端口转发,也叫 隧道 <code>tunnel</code> , 能封装一些没有加密功能的tcp协议 telnet ,smtp 等  让这些不安全的协议的数据包由ssh 加密后安全传输, 而且能通过跳板机穿透防火墙的限制等.</p><a id="more"></a><h3 id="ssh-端口转发实例"><a href="#ssh-端口转发实例" class="headerlink" title="ssh 端口转发实例"></a>ssh 端口转发实例</h3><h4 id="场景一"><a href="#场景一" class="headerlink" title="场景一:"></a>场景一:</h4><p><img src="http://47.91.157.219/ssh/ssh.png" alt="本地转发"></p><ul><li>公司内有两台服务器 <code>172.18.0.10</code>  <code>172.18.0.11</code>  两台机器都是内网机器,相互之间可以通信</li><li><code>172.18.0.10</code> 这台机器由两个IP 里一个是公网地址 <code>61.160.21.3</code> 可以与互联网通信,而且防火墙只允许这台机器ssh的22端口通过.</li><li><code>192.168.0.25</code> 是公司的一个出差员工, 想要访问 公司内网中 <code>172.18.0.11</code> 服务器.  但他只能远程 <code>61.160.21.3</code> 到这台主机上.</li></ul><p>在这样的情况下就可利用ssh的隧道功能访问</p><blockquote><p>员工如果是linux系统可以运行以下命令</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -L 1080:172.18.0.11:80  61.160.21.3</div></pre></td></tr></table></figure><p>分析 : <code>-L</code>  : local表示本地转发 ,如图所示 客户端自己开个端口 <code>1080</code> 监听自己ip的 1080 端口 , 所有通过这个 端口的数据包,都会由 客户端和<code>61.160.21.3</code> 连接的ssh 加密后安全送到 <code>61.160.21.3</code> </p><p><code>172.18.0.11:80</code> 这台服务器解密后发现里面是个 <code>172.18.0.11:80</code> ,就去找这台服务器, 响应后原路返回</p><p>注意 : 运行这条命令后,客户端会ssh登陆到    <code>61.160.21.3</code>  服务器上 ,此时隧道已经搭建好 , 浏览器中输入 </p><p><code>http://127.0.0.1:1080</code> 相当于间接访问  <code>http://172.18.0.11:80</code> </p><blockquote><p>windous服务器可以利用xhell来搭建隧道</p></blockquote><p>搭建方式:<br>选择远程主机ip地址</p><p><img src="http://47.91.157.219/ssh/ssh2.png" alt="本地转发"></p><p>点击隧道 —&gt; 添加—&gt;选择类型—&gt;源主机—&gt;目标主机—&gt;目标端口</p><p><img src="http://47.91.157.219/ssh/ssh3.png" alt="本地转发"></p><p>然后连接登陆上去就可以了,这样的就叫本地转发</p><h4 id="场景二"><a href="#场景二" class="headerlink" title="场景二 :"></a>场景二 :</h4><p><img src="http://47.91.157.219/ssh/ssh4.png" alt="远程转发"></p><p>如图如果在公司里``想访问家里电脑的资源,而且有一台公司的服务器,就可以使用远程转发的方式前提条件</p><ul><li>你对服务器<code>103.27.14.2</code> 由管理权限,能控制监听的端口</li><li>ssh命令需要在被访问的的机器上运行,例如: 公司内网机器访问家庭的,需要在家庭机器上开隧道</li><li>被访问的机器需要开发端口,一般pc机防火墙会默认阻止外来的主动连接</li></ul><blockquote><p>如果家庭内网机器 <code>192.18.31.2</code> 是linux主机 可以运行</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -R 1080:192.18.31.2:80 103.27.14.2</div></pre></td></tr></table></figure><p><code>-R</code> :表示开启远程转发, <code>192.18.31.2</code> 与 <code>103.27.14.2</code> 建立ssh 隧道后,相当与 <code>103.27.14.2</code> 这个有公网地址的服务器帮你监听 <code>1080</code> 端口, 并把通过这个端口的所有连接 转成 访问<code>192.18.31.2:80</code>的请求公司内网中的机器就可以利用 <code>http://103.27.14.2:1080</code> 的url 访问家庭内网中的主机 .</p><p>这种方式有点类似与 在路由器上做端口映射,但是一般家庭的路由ip地址是动态获取,不是固定的.还要用申请动态域名的东西, 非常麻烦,linux一条命令搞定</p><blockquote><p>如果windons可以用xshell做隧道如下方式</p></blockquote><p>选择远程主机地址,和本地端口转发一样</p><p><img src="http://47.91.157.219/ssh/ssh5.png" alt="远程转发"></p><h4 id="场景三"><a href="#场景三" class="headerlink" title="场景三:"></a>场景三:</h4><p>有墙的地方</p><p>我们可以利用 ssh + sock5 的方式,穿透防火墙 , sock5 是一种动态代理技术,</p><p>ssh使用代理的命令为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh -D 1080 &lt;remote_host&gt;      # &lt;remote_host&gt; 表示任意一台墙外的服务器主机</div></pre></td></tr></table></figure><p>前提条件:</p><ul><li>你要有一台墙外的服务器并且能有个能ssh上去的普通用户</li></ul><p>windous使用xhell 翻越防火墙实例:</p><p>选择类型为动态隧道</p><p><img src="http://47.91.157.219/ssh/ssh6.png" alt="动态转发"></p><p>远程上去后配置浏览器代理 firefox为例:</p><p>依次选择  菜单—&gt;选项—&gt;高级—&gt;网络—&gt;设置<br><img src="http://47.91.157.219/ssh/ssh7.png" alt="动态转发"></p><p>设置中选择监听本地的 <code>1080</code> 端口, 可以自己定义,与xhell中保持一致即可</p><p><img src="http://47.91.157.219/ssh/ssh8.png" alt="动态转发"></p><p>xshell连接成功后,点击 查看–&gt;隧道窗格–&gt;转义规则, 即可查看隧道连接情况,绿色小点表示成功</p><p><img src="http://47.91.157.219/ssh/ssh9.png" alt="动态转发"></p><p>之后就可以访问你想要的网站</p><p><img src="http://47.91.157.219/ssh/ssh10.png" alt="动态转发"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ssh隧道&quot;&gt;&lt;a href=&quot;#ssh隧道&quot; class=&quot;headerlink&quot; title=&quot;ssh隧道&quot;&gt;&lt;/a&gt;ssh隧道&lt;/h3&gt;&lt;p&gt;ssh通常用于加密的远程登陆,其他ssh功能非常强大,其中一个就是端口转发,也叫 隧道 &lt;code&gt;tunnel&lt;/code&gt; , 能封装一些没有加密功能的tcp协议 telnet ,smtp 等  让这些不安全的协议的数据包由ssh 加密后安全传输, 而且能通过跳板机穿透防火墙的限制等.&lt;/p&gt;
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="ssh" scheme="http://yoursite.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>ssh客户端命令</title>
    <link href="http://yoursite.com/2017/09/14/2017-09-14-openssh/"/>
    <id>http://yoursite.com/2017/09/14/2017-09-14-openssh/</id>
    <published>2017-09-13T16:00:00.000Z</published>
    <updated>2017-10-06T08:10:14.094Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ssh客户端"><a href="#ssh客户端" class="headerlink" title="ssh客户端"></a>ssh客户端</h3><p>ssh客户端有很多,window下xshell ,secureCRT ,putty 等 linux一般都是用 openssh,集成了客户端服务端,通用组件库等,还有一款轻便的 dropbear</p><a id="more"></a><h3 id="ssh命令基本用法"><a href="#ssh命令基本用法" class="headerlink" title="ssh命令基本用法"></a>ssh命令基本用法</h3><blockquote><p>语法</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh [user@]remotehost [COMMAND]</div></pre></td></tr></table></figure><blockquote><p>选项</p></blockquote><p><code>-p</code> port : 指定远程端口,缺省为22 ,这个值可以在 <code>/etc/ssh/ssh_config</code> 中修改</p><p><code>-b</code> :指定链接的源IP (客户端有多个ip时,需要用指定ip时用)</p><p><code>-C</code> : 压缩方式,远程时压缩数据包后传送,一般没有必要</p><p><code>-v</code> :查看登陆时的详细信息,通常用于调试排错</p><p><code>-X</code> : 支持x11 转发,能传送服务器端的图形界面显示到本地 (需要服务器开启: <code>ForwardX11Trusted yes</code>  默认是开启的 )</p><p><code>-Y</code> : 信任x11 转发</p><h3 id="ssh登陆方式"><a href="#ssh登陆方式" class="headerlink" title="ssh登陆方式"></a>ssh登陆方式</h3><p>登陆的简单过程是,客户端向服务器发起远程连接请求,服务器端收到消息后响应,客户端与服务器协商传输的ssh版本(v1,和v2) , 加密的方式(rsa,dsa等) .确定好后发送相应的密钥(<code>/etc/ssh/*</code> 目录下,不同版本的钥匙一共三对 ) 给客户端, 客户端收到发来的密钥检查文件  <code>~/.ssh/known_hosts</code> 下是否有之前信任过的公钥,没有的话需要用户输入 <code>yes</code> 信任此密钥,之后输入密码验证,或密钥认证 , 之后会自动协商对称密钥进行加密传输</p><p>ssh有两种登陆方式:</p><ul><li>使用口令认证</li><li>使用密钥认证</li></ul><blockquote><p>口令认证</p></blockquote><p>口令认证是交互式的,不适合脚本的环境,和大规模的运维环境,而且口令再网上传输也不安全.</p><blockquote><p>使用密钥认证</p></blockquote><p>实现密钥认证的过程: </p><p>1 客户端生成一对密钥,一般生成私钥即可,公钥是从私钥中提取,程序会自动进行</p><p>2 将公钥copy到远程主机对应的家目录下 <code>~/.ssh/authorized_keys</code>  ,这是一个文件,如果有多个用户的公钥再这,要追加放进来,不能覆盖</p><h4 id="实现密钥认证"><a href="#实现密钥认证" class="headerlink" title="实现密钥认证"></a>实现密钥认证</h4><blockquote><p><code>ssh-keygen</code>生成密钥对</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-keygen -t rsa -P '123456' -f /root/.ssh/id_rsa</div></pre></td></tr></table></figure><p>分析 : <code>-P</code> 指定加密私钥的密码, <code>-f</code> 指定生成的密钥名 (文件名不能随便命名,手动指定是为了,避免敲回车键) <code>-t</code>  指定加密方式 为rsa 缺省为rsa</p><blockquote><p>发送公钥到远程主机</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ssh-copy-id -i /root/.ssh/id_rsa.pub root@172.18.5.60</div></pre></td></tr></table></figure><p><code>-i</code> 指定公钥文件(不要复制私钥文件) </p><blockquote><p>公钥分发</p></blockquote><p>生产环境中,一般都是安装系统后已经copy好公钥到.远程主机,或者使用脚本分发,脚本如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span>!/bin/bash</div><div class="line"><span class="meta">#</span> expect 脚本copy密钥自动输入密码</div><div class="line">copy_key() &#123;</div><div class="line">    expect &lt;&lt; EOF</div><div class="line">set timeout 3</div><div class="line">spawn ssh-copy-id -i $key_name $&#123;2&#125;@$&#123;1&#125;</div><div class="line">    expect &#123;</div><div class="line">    "(yes/no)?" &#123; send "yes\n";exp_continue &#125;</div><div class="line">    "password" &#123; send "$&#123;3&#125;\n";exp_continue &#125;</div><div class="line">&#125;</div><div class="line">expect eof</div><div class="line">EOF</div><div class="line">&#125;</div><div class="line"><span class="meta">#</span> 设置主机列表格式为每行 ip host password (eg: 172.18.5.60 root 123456)</div><div class="line">host_list=/tmp/host.txt</div><div class="line"><span class="meta">#</span> 指定公钥文件位置</div><div class="line">key_name=/root/.ssh/id_rsa.pub</div><div class="line"></div><div class="line">if ! rpm -q expect &amp;&gt;/dev/null;then</div><div class="line">    yum install -y q expect || exit 3</div><div class="line">fi</div><div class="line">[ ! -e $host_list ] &amp;&amp; echo "Error:create a host list before." &amp;&amp; exit 2</div><div class="line">ip=(`awk '&#123;print $1&#125;' $host_list`)</div><div class="line">user=(`awk '&#123;print $2&#125;' $host_list`)</div><div class="line">password=(`awk '&#123;print $3&#125;' $host_list`)</div><div class="line"></div><div class="line">for((i=0;i&lt;$&#123;#ip[*]&#125;;i++));do</div><div class="line">    &#123;</div><div class="line">    copy_key $&#123;ip[$i]&#125; $&#123;user[$i]&#125; $&#123;password[$i]&#125; &amp;&gt;/dev/null</div><div class="line">    if [ $? -eq 1 ];then</div><div class="line">         echo -e "$&#123;ip[$i]&#125; : send ssh_key[\033[32m success \033[0m]"</div><div class="line">    else</div><div class="line">         echo -e "$&#123;ip[$i]&#125; : send ssh_key[\033[31m failure \033[0m]"</div><div class="line">    fi</div><div class="line">    &#125; &amp;</div><div class="line">done</div><div class="line">wait</div></pre></td></tr></table></figure><blockquote><p>windons下生成密钥,一样原理xshell为例:</p></blockquote><p>工具–&gt; 用户密钥管理者–&gt;生成–&gt;copy到主机即可</p><h4 id="密钥代理"><a href="#密钥代理" class="headerlink" title="密钥代理"></a>密钥代理</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ssh-agent bash               # 启动代理</div><div class="line">ssh-add                      # 将密码交给agent代理 仅需输入一次私钥口令</div></pre></td></tr></table></figure><p>注意: 托管后本次会话,不需要输入密码,但安全起见终端退出后失效</p><h3 id="基于ssh远程copy命令"><a href="#基于ssh远程copy命令" class="headerlink" title="基于ssh远程copy命令"></a>基于ssh远程copy命令</h3><h4 id="scp命令"><a href="#scp命令" class="headerlink" title="scp命令"></a>scp命令</h4><blockquote><p>语法</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">scp [options] [user@]host:/sourcefile /destpath       #语法和cp命令一样</div></pre></td></tr></table></figure><blockquote><p>常用选项</p></blockquote><p><code>-C</code> :压缩数据流</p><p><code>-r</code> :递归复制,复制目录用</p><p><code>-p</code> :保持元属性</p><p><code>-P</code> :指定端口</p><p>注意: scp 适合小文件的简单复制,而且目标文件如果存在且一摸一样,会覆盖,影响效率</p><h4 id="rsync-命令"><a href="#rsync-命令" class="headerlink" title="rsync 命令"></a>rsync 命令</h4><p>rysnc作用是基于ssh和rsh服务实现高效率的远程系统之间复制文件,属于增量备份,而且可以定义复制特定的文件,实现任务计划自动同步. 客户端命令的基本用法为:</p><blockquote><p>语法</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rsync [OPTION...] [USER@]HOST:SRC... [DEST]   # 复制到本地</div><div class="line">rsync [OPTION...] SRC... [USER@]HOST:DEST     # 推送到远程主机</div></pre></td></tr></table></figure><blockquote><p>常用选项</p></blockquote><p><code>n</code>  模拟复制过程</p><p><code>-v</code>  显示详细过程</p><p><code>-r</code>  递归复制目录树</p><p><code>-p</code>  保留权限</p><p><code>-t</code>  保留时间戳</p><p><code>-g</code>  保留组信息</p><p><code>-o</code>保留所有者信息</p><p><code>-l</code> 将软链接文件本身进行复制（默认）</p><p><code>-L</code> 将软链接文件指向的文件复制</p><p><code>-a</code>  存档，相当于–rlptgoD，但不保留ACL（-A）和SELinux属性（-X）</p><blockquote><p>例子</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">rsync -av 172.18.5.61:/etc/ /tmp/             # 注意两条命令的区别</div><div class="line">rsync -av 172.18.5.61:/etc /tmp/</div></pre></td></tr></table></figure><p>rsync 命令行用法和 scp几乎一样, 只是rsync 不是全部赋值,只复制不同的文件</p><h3 id="sshd服务端配置"><a href="#sshd服务端配置" class="headerlink" title="sshd服务端配置"></a>sshd服务端配置</h3><p>sshd的服务是服务器必须开放的一个,容易被扫描到,以及暴力破解,通常需要做的优化配置有一下方面</p><p>修改的配置文件为 <code>/etc/ssh/sshd_config</code> </p><ul><li>禁用管理员root账户直接登陆远程主机, root直接登陆网络上传输容易被别人抓包获取,虽然时加密过的,但是也有暴力破解分析的手段,所以要禁止</li><li>更改默认监听的端口,22端口人人皆知,改成其他端口迷惑别人</li><li>控制特定的ip访问,不要监听所有IP,只允许特定ip访问</li><li>限制用户登陆</li><li>不要使用不安全的 ssh v1 版本</li><li>使用基于密钥认证 (密钥认证方便管理,而且比口令登录更安全)</li></ul><p>基于默认配置可以更改为如下配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">UseDNS no                                # 禁止解析DNS 可提高链接速度  默认yes</div><div class="line">GSSAPIAuthentication no                  # 运行GSSAPI 认证可以改为no 可以提供连接速度 默认yes</div><div class="line">Port XXX                                 # 该端口 为了安全    默认22</div><div class="line">ListenAddress X.X.X.X                    # 改为指定ip,192.18.1.0 表示网段  # 默认全部监听</div><div class="line">PermitRootLogin no                       # 建议改成no  默认yes</div><div class="line">MaxAuthTries 6                           # 最多尝试密码次数 ,保持默认</div><div class="line">PermitEmptyPasswords no                  # 不允许空密码 保持默认</div><div class="line">AllowUsers user1 user2 user3             # 白名单登陆用户列表,默认没有自己添加</div><div class="line">AllowGroups group1 group2                # 白名单登陆组列表,默认没有 ,对应还有 deny的黑名单</div></pre></td></tr></table></figure><p>更多配置参考<a href="http://www.jinbuguo.com/openssh/sshd_config.html" target="_blank" rel="external">sshd_config 中文手册</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ssh客户端&quot;&gt;&lt;a href=&quot;#ssh客户端&quot; class=&quot;headerlink&quot; title=&quot;ssh客户端&quot;&gt;&lt;/a&gt;ssh客户端&lt;/h3&gt;&lt;p&gt;ssh客户端有很多,window下xshell ,secureCRT ,putty 等 linux一般都是用 openssh,集成了客户端服务端,通用组件库等,还有一款轻便的 dropbear&lt;/p&gt;
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="ssh" scheme="http://yoursite.com/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>opessl和CA</title>
    <link href="http://yoursite.com/2017/09/10/2017-09-10-openssl/"/>
    <id>http://yoursite.com/2017/09/10/2017-09-10-openssl/</id>
    <published>2017-09-09T16:00:00.000Z</published>
    <updated>2017-10-06T08:10:14.092Z</updated>
    
    <content type="html"><![CDATA[<h3 id="openssl简介"><a href="#openssl简介" class="headerlink" title="openssl简介"></a>openssl简介</h3><p><code>openssl</code> 用于实现<code>http</code> <code>ftp</code> <code>smtp</code> 等一些应用层的加密传输,保证数据的安全性. http 协议等本身不具备加密解密的功能,  数据在明文在网上传输 , 对于一些保密性要求高的行业,(电商,网银支付的) ,以<code>https</code> 开头的就表示加密传输的 .</p><a id="more"></a><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><h4 id="加密和解密种类"><a href="#加密和解密种类" class="headerlink" title="加密和解密种类"></a>加密和解密种类</h4><p>加密和<code>encrypt</code> 解密 <code>decrypt</code> 大致有三种,每种又有很多不同的算法,互联网加密安全传输过程中这三种类型的加密算法都要,用到根据不同的特性实现不同的功能.</p><p><code>对称加密</code>  :加密和解密使用同一个密钥 ,常用的由 <code>3DES</code> <code>AES</code> 等. 其特点有:</p><ul><li>加密和解密使用同一个密钥.效率高</li><li>密钥过多,密钥分发,数据来源无法确认</li></ul><p><code>非对称加密</code> : 密钥是成对出现的 公钥 <code>public key</code> 和私钥 <code>private key</code> ,公钥用于公开给所有人</p><p>私钥这是留给自己保存. </p><p>加密的方法 :公钥和私钥都可以加密数据, 一种密钥加密的数据另一个配对的密钥才能解密. 由于私钥有不公开,一般由一人保存,所以有一下功能:</p><ul><li>用于数字签名, alice用私钥加密过的数据,用alice的公钥能解密,表示提供此数据是有alice本人加密的,从而判断了此数据的来源合法性</li><li>用于对称密钥的交换, 非对称密钥长,加密速度极慢,通常不会用于互联网上数据加密传输, 通常做法是两台主机协商一个共同的对称密钥 ,然后相互用对方主机的公钥加密对称密钥.传输后验证对方的主机. 验证完成后,使用对称密钥传输数据</li></ul><p>非对称加密的算法有 : <code>RSA</code>  <code>DSA</code>    ,通常rsa可以用来 加密,数字签名; dsa只能用户数字签名</p><p><code>单向加密</code> :单向加密的功用是只能加密不能解密, 通常叫做提取数据特征码,指纹等 ,单向加密的特征有:</p><ul><li>无论源数据是什么,加密后的数据是固定长度</li><li>数据的细小改变,特征码会发生巨大差别 (雪崩效应)</li><li>无法解密</li></ul><p>从单向加密的特征,通常用作验证数据的完整性,防止数据在传输过程中被篡改</p><p>单向加密的算法有 <code>md5</code> , <code>sha</code> 等 </p><p><code>IKE</code>  Internet Key Exchange 互联网密钥交换 ,实现这个功能的算法叫 <code>DH</code> ,特点是: 双方主机协商产生密钥,只需要交换一些随机数,而密钥本身不需要在互联网上传输,增强了安全性</p><h4 id="PKI"><a href="#PKI" class="headerlink" title="PKI"></a>PKI</h4><p><code>PKI</code>  全称为 <code>Pbulic Key Infrastructure</code>  公钥基础设施 , 是实现公钥管理的一总规范和标准,实现这种规范管理的第三方管理机构,叫做 <code>CA</code> </p><p><code>CA</code> : Certificate Authority 证书鉴证机构</p><p><code>RA</code> : Register Authority  证书注册机构, RA 负责接受企业的申请,统一提交CA 签署</p><p><code>CRL</code> :Certificates Revoke List  证书吊销列表,证书会丢失,和过期. 列表内的表示不可用</p><p><code>x509</code> :定义了证书的格式和认证协议的标准 .</p><h4 id="加密协议"><a href="#加密协议" class="headerlink" title="加密协议"></a>加密协议</h4><p><code>SSL</code>  Secure Socket  Layer 安全的套接字层协议 </p><p><code>TLS</code> Transaction Layer Secure  是ssl的增加版目前使用最多版本是 <code>tls 2.0</code> </p><p>ssl/tls : 工作在应用层和tcp/ip协议之间, http封装过的数据包(文本格式)要由 ssl 验证后转为二进制格式,传给下一层.</p><p>ssl/tls 协议层很复杂,提供加密之前需要交换密钥,验证身份,最后加密数据.</p><p>注意 : ssl 会话的建立只能建立在ip地址上,这就意味这如果 web服务器,上建立了多个虚拟机主机,只有其中一个能实现加密功能</p><h3 id="openssl-程序"><a href="#openssl-程序" class="headerlink" title="openssl 程序"></a>openssl 程序</h3><p>centos系统中实现这种功能的软件包也叫 <code>openssl</code> 是 <code>SSL</code> 协议的一种开源的实现</p><p><code>openssl</code> 程序由三个重要的组成部分:</p><ul><li><code>libcrypto</code> :加密库,提供各种算法的函数. 各种程序大都需要这个库,是一个基本的组件</li><li><code>libssl</code> : 用于实现 TLS/SSL 协议 </li><li><code>opensll</code> :命令行的工具, 由很多子命令</li></ul><h3 id="openssl-命令"><a href="#openssl-命令" class="headerlink" title="openssl 命令"></a>openssl 命令</h3><h4 id="子命令"><a href="#子命令" class="headerlink" title="子命令"></a>子命令</h4><blockquote><p><code>enc</code> 用于对称加密的 </p></blockquote><p>openssl enc –help 查看帮助 或者 man enc  </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl enc -e -aes-256-cfb -a -salt -in fstab -out fstab.cipher</div></pre></td></tr></table></figure><p><code>-e</code>  表示加密  <code>-aes-256-cfb</code>  指定算法  <code>-a</code>  指定以base64 文本格式输出  <code>-salt</code>  加盐  <code>-in</code>  指定要加密的文件  <code>-out</code>  表示加密后输出的文件</p><blockquote><p><code>dgst</code> 用于单向加密</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 指定加密方式即可</div><div class="line">openssl dgst -sha512 fstab</div><div class="line">sha512sum fstab</div></pre></td></tr></table></figure><p>拓展 : <code>MAC</code>  Message Authentication Code  消息认证码. 单向加密一种延伸应用 ,主要用于实现在网络通信中所有传输中保证所有传输数据完整性, 不关心其他的 . 这是一种算法</p><p>实现<code>MAC</code> 的应用有 <code>CBC-MAC</code>  <code>HMAC</code> 主要应用与集群环境中</p><blockquote><p><code>passwd</code> 生成用户密码</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl passwd -1 -salt 345hsa</div></pre></td></tr></table></figure><p><code>-1</code> 指定是用md5 加密 <code>-salt</code>  345hsa  ,后面跟随机数不超过8位</p><blockquote><p><code>rand</code> 生成随机数</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl rand -hex 8</div></pre></td></tr></table></figure><p><code>-hex</code>  指定十六机制输出  输出为9个字节</p><blockquote><p><code>genrsa</code> 生成私钥</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl genrsa -out rsakey.private 2048</div></pre></td></tr></table></figure><p>注意 : 要修改私钥的权限, 保证安全用 <code>enc</code> 对称加密</p><p>公钥是从私钥中提取出来的</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl rsa -in rsakey.private -pubout</div></pre></td></tr></table></figure><p>注意: 公钥默认输出到终端, 保存请重定向,</p><h3 id="搭建私有CA"><a href="#搭建私有CA" class="headerlink" title="搭建私有CA"></a>搭建私有CA</h3><p>步骤为 1: 生成rsa密钥对  2: 生成自签证书</p><p>配置文件路径 <code>/etc/pki/tls/openssl.cnf</code>   查看<code>[  CA_default ]</code>  配置段</p><p>必须备需要的文件和目录</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">private_key = private/cakey.pem        # 私钥的后缀和路路径</div><div class="line">certificate = $dir/cacert.pem          # 证书的后缀和路径</div><div class="line">serial      = $dir/serial              # 要创建序列号文件 echo 01</div><div class="line">database    = $dir/index.txt           # 要创建索引目录</div><div class="line">certs       = $dir/certs               # 准备证书目录</div><div class="line">new_certs_dir   = $dir/newcerts        # 准备新签署证书目录</div><div class="line">crl_dir     = $dir/crl                 # 准备证书吊销列表</div></pre></td></tr></table></figure><blockquote><p>1 生成私钥</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">(umask 077;openssl genrsa -out /etc/pki/CA/private/cakey.pem -des 2048)</div></pre></td></tr></table></figure><p><code>-des</code> 指定为私钥加密, <code>umask 007</code> 保证密钥生成是的权限最小</p><blockquote><p>生成自签证书</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd /etc/pki/CA</div><div class="line">openssl req -new -x509 -key private/cakey.pem -out cacert.pem -days 3650</div></pre></td></tr></table></figure><p>注意: 使用的相对路径</p><blockquote><p>查看证书以可读方式</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl x509 -text -in cacert.pem       # 证书的x509的标准格式</div></pre></td></tr></table></figure><blockquote><p>生成证书颁发请求</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">(umask 077; openssl genrsa -out /tmp/http.key 2058)</div><div class="line">openssl req -new -key /tmp/http.key -out /tmp/http.csr</div></pre></td></tr></table></figure><p>注意: </p><ul><li>每种服务都需要证书,以http为例 ,证书申请一般都是其他主机.</li><li>默认国家,省,市,公司名称要也<code>CA</code> 的保持一致 . 而且 <code>server&#39;s name</code>  就是写此web服务器对外提供的域名</li><li>证书颁发请求必须要以<code>.csr</code> 格式结尾</li></ul><blockquote><p><code>ca</code> 证书管理,签署证书颁发请求<code>.csr</code> 文件(Cerificate Signing Request)</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">openssl ca -in http.csr -out /etc/pki/CA/certs/http.crt -days 365</div></pre></td></tr></table></figure><p>签好好发给请求方,他就可以使用了</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;openssl简介&quot;&gt;&lt;a href=&quot;#openssl简介&quot; class=&quot;headerlink&quot; title=&quot;openssl简介&quot;&gt;&lt;/a&gt;openssl简介&lt;/h3&gt;&lt;p&gt;&lt;code&gt;openssl&lt;/code&gt; 用于实现&lt;code&gt;http&lt;/code&gt; &lt;code&gt;ftp&lt;/code&gt; &lt;code&gt;smtp&lt;/code&gt; 等一些应用层的加密传输,保证数据的安全性. http 协议等本身不具备加密解密的功能,  数据在明文在网上传输 , 对于一些保密性要求高的行业,(电商,网银支付的) ,以&lt;code&gt;https&lt;/code&gt; 开头的就表示加密传输的 .&lt;/p&gt;
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="openssl" scheme="http://yoursite.com/tags/openssl/"/>
    
  </entry>
  
  <entry>
    <title>centos7 systemd</title>
    <link href="http://yoursite.com/2017/09/08/2017-09-08-systemd/"/>
    <id>http://yoursite.com/2017/09/08/2017-09-08-systemd/</id>
    <published>2017-09-07T16:00:00.000Z</published>
    <updated>2017-10-06T08:10:14.091Z</updated>
    
    <content type="html"><![CDATA[<h3 id="systemd简介"><a href="#systemd简介" class="headerlink" title="systemd简介"></a>systemd简介</h3><p>centos6 之前一直采用的是<code>sysVinit</code> ,是内核加载完成后,启动的第一个进程(pid 为1), 主要用于管理系统各种服务的启动<br><code>/etc/rc.d/init.d/*</code> 目录下的文件就是启动各类服务的脚本文件.</p><p>由于<code>init</code> 程序只是用来执行脚本的,<code>init</code> 程序按照配置文件<code>/etc/inittab</code>中的次序,启动各个对应路径下的脚本文件,导致开机速度慢,服务脚本冗长,且功能单一</p><a id="more"></a><p><code>Systemd</code> 因此为解决这些问题诞生,再centos7 中systemd 就是系统启动的第一个进程, 接管了系统的各个方面, 控制着系统的几乎所有源(service ,scoket 等).</p><blockquote><p>Sytemd较init程序的一些新特性</p></blockquote><ul><li>系统引导时实现并行启动</li><li>按需启动守护进程</li><li>自动化服务依赖关系管理</li><li>同时采用socket式与D-Bus总线式激活服务</li><li>支持系统状态快照</li></ul><p>systemd 之所以能够并行启动,是因为systemd并不是真正的启动服务,而是类似<code>xinetd</code> 这个超级守护进程类似,帮进程监听端口,当服务被访问时才将这个服务唤醒,和根据服务的配置文件中,定义的依赖关系,唤醒依赖的服务和进程. 这个配置文件叫做 <code>Unit</code></p><h3 id="systemd核心概念"><a href="#systemd核心概念" class="headerlink" title="systemd核心概念"></a>systemd核心概念</h3><p>unit表示不同类型的systemd对象，通过配置文件进行标识和配置；文件中主要包含了系统服务、监听socket、保存的系统快照以及其它与init相关的信息,</p><p>运行下面命令,可查看所有Unit 类型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;root: ~&gt;# systemctl -t help</div><div class="line">automount  device     path       snapshot   swap       timer      </div><div class="line">busname    mount      service    socket     target</div></pre></td></tr></table></figure><p>unit单元的命名都是,服务名称加类型后缀 例如 <code>httpd.service</code>  <code>telnet.socket</code></p><blockquote><p>各种unit类型表示含义如下</p></blockquote><table><thead><tr><th>unit类型</th><th>描述</th></tr></thead><tbody><tr><td>.service</td><td>定义系统服务</td></tr><tr><td>.target</td><td>模拟运行级别的</td></tr><tr><td>.device   .swap</td><td>用于定义内核识别的设备/交换分区</td></tr><tr><td>.mount   .automount</td><td>定义文件系统挂载点/自动挂载</td></tr><tr><td>.snapshot</td><td>管理系统快照</td></tr><tr><td>.path</td><td>用于定义文件系统中的一个文件或目录使用,常用于当文件系统变化时，延迟激活服务</td></tr><tr><td>.socket</td><td>用于标识进程间通信用的socket文件，也可在系统启动时，延迟启动服务，实现按需启动</td></tr></tbody></table><h3 id="重要目录和文件"><a href="#重要目录和文件" class="headerlink" title="重要目录和文件"></a>重要目录和文件</h3><ul><li>/usr/lib/systemd/system/ 这个目录下,包含了所有的unit 文件</li><li>/run/systemd/system/ 这个目录是系统执行过程中产生的脚本</li><li>/etc/systemd/system/ 这个目录文件较少,绝大多数都是指向,/usr/lib/systemd/system 目录下的个文件.</li></ul><h3 id="systemd加载文件次序"><a href="#systemd加载文件次序" class="headerlink" title="systemd加载文件次序"></a>systemd加载文件次序</h3><p>systemd启动找的第一配置文件是 <code>/etc/systemd/default.target</code> , 这个文间的内容如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[Unit]</div><div class="line">Description=Multi-User System</div><div class="line">Documentation=man:systemd.special(7)</div><div class="line">Requires=basic.target</div><div class="line">Conflicts=rescue.service rescue.target</div><div class="line">After=basic.target rescue.service rescue.target</div><div class="line">AllowIsolate=yes</div></pre></td></tr></table></figure><p>其中: <code>Requires</code> 表示需求(强制依赖的) . 这个程序启动是强制依赖 <code>basic.target</code> ,所以系统再去找 <code>basic.target</code> 直到启动所有依赖的<code>unit</code> </p><p>根据unit文件的引导,大致启动的次序为:</p><ol><li>执行sysinit.target 初始化系统</li><li>执行basic.target 设置操作系统环境</li><li>执行multi-user.target下的本机与服务器服务</li><li>执行multi-user.target下的/etc/rc.d/rc.local</li><li>执行multi-user.target下的getty.target及登录服务</li></ol><h3 id="管理命令"><a href="#管理命令" class="headerlink" title="管理命令"></a>管理命令</h3><p>主要是管理<code>.service</code> 类的,以<code>httpd.service</code> 为例,其中后缀可以省略</p><h4 id="服务重启-重载-停止"><a href="#服务重启-重载-停止" class="headerlink" title="服务重启/重载/停止"></a>服务重启/重载/停止</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 条件式重启：已启动才重启，否则不做操作</div><div class="line">systemctl try-restart httpd</div><div class="line"><span class="meta">#</span> 重载或重启服务：先加载，再启动</div><div class="line">systemctl reload-or-restart httpd.service</div><div class="line"><span class="meta">#</span> 重载或条件式重启服务</div><div class="line">systemctl reload-or-try-restart httpd.service</div><div class="line"><span class="meta">#</span> 设定某服务开机自启</div><div class="line">systemctl enable httpd.service</div><div class="line"><span class="meta">#</span> 设定某服务开机禁止启动</div><div class="line">systemctl disable httpd.service</div><div class="line"><span class="meta">#</span> 禁止自动和手动启动</div><div class="line">systemctl mask httpd.service</div><div class="line"><span class="meta">#</span> 取消禁止</div><div class="line">systemctl unmask httpd.service</div></pre></td></tr></table></figure><p>禁止启动实际上是创建etc/systemd/system/httpd.service 指向/dev/nul 下的软连接</p><h4 id="服务状态查看"><a href="#服务状态查看" class="headerlink" title="服务状态查看"></a>服务状态查看</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 查看某服务当前激活与否的状态</div><div class="line">systemctl status httpd.service</div><div class="line"><span class="meta">#</span> 查看所有util的开机自启状态</div><div class="line">systemctl list-units --type --all</div><div class="line"><span class="meta">#</span> 查看所有service的开机自启状态</div><div class="line">systemctl list-units --type service</div><div class="line"><span class="meta">#</span> 查看当前激活的所有服务状态</div><div class="line">systemctl list-unit-files --type service</div><div class="line"><span class="meta">#</span> 列出失败的服务</div><div class="line">systemctl --failed --type=service</div><div class="line"><span class="meta">#</span> 查看服务的依赖关系</div><div class="line">systemctl list-dependencies name.service</div><div class="line"><span class="meta">#</span> 查看unit设置的详细信息</div><div class="line">systemctl show httpd.service</div><div class="line"><span class="meta">#</span> 查看指定unit的内容</div><div class="line">systemctl cat httpd.service</div></pre></td></tr></table></figure><h4 id="切换运行级别"><a href="#切换运行级别" class="headerlink" title="切换运行级别"></a>切换运行级别</h4><p>systemd 已经没有运行级别,但保留了原来的说法, .target就是与运行级别有关</p><p>multi-user.target 对应原来的 2 3 4  级别 , poweroff.target 对应 0 级别 ,reboot.target 对应 6 级别, graphical.target 对应 5 级别 , rescue.target 对应 1 级别</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 获取当前运行级别</div><div class="line">systemctl get-default</div><div class="line"><span class="meta">#</span> 设置运行级别 ,自动补全在这有问题</div><div class="line">systemctl set-default multi-user.target</div><div class="line"><span class="meta">#</span> 切换救援模式</div><div class="line">systemctl rescue</div><div class="line"><span class="meta">#</span> 切换到紧急救援模式</div><div class="line">systemctl emergency</div></pre></td></tr></table></figure><h4 id="其他相关命令"><a href="#其他相关命令" class="headerlink" title="其他相关命令"></a>其他相关命令</h4><blockquote><p>设置主机名</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 查看主机名信息</div><div class="line">hostnamectl </div><div class="line"><span class="meta">#</span> 设置主机名,注意会同步到配置文件</div><div class="line">hostnamectl set-hostname www.zxs.com</div></pre></td></tr></table></figure><blockquote><p>设置字符集</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 查看本地字符集,键盘映射</div><div class="line">localectl</div><div class="line"><span class="meta">#</span> 设置字符集</div><div class="line">localectl set-locale LANG=en_US.utf8</div></pre></td></tr></table></figure><blockquote><p>设置时钟</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 设置时区,注意 cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime 貌似无效</div><div class="line">timedatectl set-timezone America/New_York</div></pre></td></tr></table></figure><blockquote><p>查看登陆会话</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#</span> 查看所有会话简要信息</div><div class="line">loginctl list-sessions</div><div class="line"><span class="meta">#</span> 查看会话的详细信息,后跟sessionID</div><div class="line">loginctl session-status 2</div></pre></td></tr></table></figure><h3 id="Unit配置文件"><a href="#Unit配置文件" class="headerlink" title="Unit配置文件"></a>Unit配置文件</h3><p>查看下 httpd.service 文件的内容命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;root: ~&gt;# systemctl cat httpd.service</div></pre></td></tr></table></figure><p>unit 服务配置文件分为三个部分</p><p><code>[Unit]</code> 定义与Unit类型无关的通用选项；用于提供unit的描述信息、unit行为及依赖关系等</p><p><code>[Service]</code> 与特定类型相关的专用选项；此处为Service类型</p><p><code>[Install]</code> 定义由“systemctl enable”以及”systemctldisable“命令在实现服务启用或禁用时用到的一些选项</p><h4 id="区块的指令含义"><a href="#区块的指令含义" class="headerlink" title="区块的指令含义"></a>区块的指令含义</h4><blockquote><p>[Unit] 指令</p></blockquote><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Description</td><td>描述信息</td></tr><tr><td>After</td><td>定义unit的启动次序，表示当前unit应该晚于哪些unit启动，其功能与Before相反</td></tr><tr><td>Requires</td><td>依赖到的其它units，强依赖，被依赖的units无法激活时，当前unit也无法激活</td></tr><tr><td>Wants</td><td>依赖到的其它units，弱依赖</td></tr><tr><td>Conflicts</td><td>定义units间的冲突关系</td></tr></tbody></table><blockquote><p>[Server] 段常用选项</p></blockquote><table><thead><tr><th>类型</th><th>含义</th></tr></thead><tbody><tr><td>Type=simple</td><td>默认值，这个daemon主要由ExecStart接的指令串来启动，启动后常驻于内存中</td></tr><tr><td>Type=forking</td><td>由ExecStart启动的程序透过spawns延伸出其他子程序来作为此daemon的主要服务。原生父程序在启动结束后就会终止</td></tr><tr><td>Type=oneshot</td><td>与simple类似，不过这个程序在工作完毕后就结束了，不会常驻在内存中</td></tr><tr><td>Type=dbus</td><td>与simple类似，但这个daemon必须要在取得一个D-Bus的名称后，才会继续运作.因此通常也要同时设定BusNname= 才行</td></tr><tr><td>Type=notify</td><td>在启动完成后会发送一个通知消息。还需要配合NotifyAccess 来让 Systemd 接收消息</td></tr><tr><td>Type=idle</td><td>与simple类似，要执行这个daemon必须要所有的工作都顺利执行完毕后才会执行。这类的daemon通常是开机到最后才执行即可的服务</td></tr><tr><td>EnvironmentFile</td><td>环境配置文件</td></tr><tr><td>ExecStart</td><td>指明启动unit要运行命令或脚本的绝对路径</td></tr><tr><td>ExecStartPre</td><td>ExecStart前运行</td></tr><tr><td>ExecStartPost</td><td>ExecStart后运行</td></tr><tr><td>ExecStop</td><td>指明停止unit要运行的命令或脚本</td></tr><tr><td>Restart</td><td>当设定Restart=1 时，则当次daemon服务意外终止后，会再次自动启动此服务</td></tr></tbody></table><blockquote><p>[Install] 段常用选项</p></blockquote><table><thead><tr><th>类型</th><th>描述</th></tr></thead><tbody><tr><td>Alias</td><td>别名，可使用systemctl command Alias.service</td></tr><tr><td>RequiredBy</td><td>被哪些units所依赖，强依赖</td></tr><tr><td>WantedBy</td><td>被哪些units所依赖，弱依赖</td></tr><tr><td>Also</td><td>安装本服务的时候还要安装别的相关服务</td></tr></tbody></table><h4 id="系统http-service分析"><a href="#系统http-service分析" class="headerlink" title="系统http.service分析"></a>系统http.service分析</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">&lt;root: ~&gt;# systemctl cat httpd.service </div><div class="line"><span class="meta">#</span> /usr/lib/systemd/system/httpd.service</div><div class="line">[Unit]</div><div class="line">Description=The Apache HTTP Server</div><div class="line">After=network.target remote-fs.target nss-lookup.target</div><div class="line">Documentation=man:httpd(8)</div><div class="line">Documentation=man:apachectl(8)</div><div class="line"></div><div class="line">[Service]</div><div class="line">Type=notify</div><div class="line">EnvironmentFile=/etc/sysconfig/httpd</div><div class="line">ExecStart=/usr/sbin/httpd $OPTIONS -DFOREGROUND</div><div class="line">ExecReload=/usr/sbin/httpd $OPTIONS -k graceful</div><div class="line">ExecStop=/bin/kill -WINCH $&#123;MAINPID&#125;</div></pre></td></tr></table></figure><p>[Unit] 区块与启动相无关, 主要分析 [Service] 区块</p><p>EnvironmentFile=/etc/sysconfig/httpd        指定的是httpd的环境配置文件,不是主配置文件</p><p>ExecStart 表示启动进程的二进制文件, 编译安装的apachectl 也可以启动</p><p><code>OPTIONS</code> 是 环境配置文件的变量, 可支持的参数可以 <code>man httpd</code> </p><p><code>MAINPID</code> 是主进程的id号</p><blockquote><p>例如</p></blockquote><p>编译安装apache时,稍作修改 系统中的<code>unit</code> 的配置文件,修改程序的路径即可 , </p><pre><code class="shell">[Unit]Description=The Apache HTTP ServerAfter=network.target remote-fs.target nss-lookup.targetDocumentation=man:httpd(8)Documentation=man:apachectl(8)[Service]<span class="meta">#</span>Type=notify<span class="meta">#</span>EnvironmentFile=/etc/sysconfig/httpd      # 编译安装没有这个环境文件注释掉ExecStart=/usr/local/apache2/bin/httpd $OPTIONS -DFOREGROUND    # 修改路径ExecReload=/usr/local/apache2/bin/httpd $OPTIONS -k graceful    # 修改路径ExecStop=/bin/kill -WINCH ${MAINPID}</code></pre><h3 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h3><p><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-part-two.html" target="_blank" rel="external">Systemd 入门教程：实战篇</a></p><p><a href="http://www.ruanyifeng.com/blog/2016/03/systemd-tutorial-commands.html" target="_blank" rel="external">Systemd 入门教程：命令篇</a></p><p><a href="http://www.jinbuguo.com/systemd/index.html" target="_blank" rel="external">systemd.index 中文手册</a></p>]]></content>
    
    <summary type="html">
    
      系统启动和服务器守护进程管理器，负责在系统启动或运行时，激活系统资源，服务器进程和其它进程
    
    </summary>
    
      <category term="linux基础" scheme="http://yoursite.com/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="systemctl" scheme="http://yoursite.com/tags/systemctl/"/>
    
  </entry>
  
  <entry>
    <title>awk基本用法</title>
    <link href="http://yoursite.com/2017/09/06/2017-09-06-awk/"/>
    <id>http://yoursite.com/2017/09/06/2017-09-06-awk/</id>
    <published>2017-09-05T16:00:00.000Z</published>
    <updated>2017-10-06T08:10:14.088Z</updated>
    
    <content type="html"><![CDATA[<h3 id="awk-工作模式"><a href="#awk-工作模式" class="headerlink" title="awk 工作模式"></a>awk 工作模式</h3><p><code>awk</code>的工作过程是这样的：按行读取输入(标准输入或文件)，对于符合模式<code>pattern</code>的行，执行<code>action</code>。当<code>pattern</code>省略时表示匹配任何字符串；当<code>action</code>省略时表示执行<code>&#39;{print}&#39;</code>；它们不可以同时省略。每一行输入，对<code>awk</code>来说都是一条记录(<code>record</code>)，<code>awk</code>使用<code>$0</code>来引用当前记录</p><a id="more"></a><blockquote><p>语法</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">awk [options] 'program'' file…</div><div class="line">awk [options] -f programfile var=value file…</div><div class="line">awk [options] 'BEGIN&#123; action;… &#125; pattern&#123; action;… &#125; END&#123;action;… &#125;' file ...</div></pre></td></tr></table></figure><h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">-F  field separator</td><td style="text-align:left">指定字段分割符</td></tr><tr><td style="text-align:left">-v var=value</td><td style="text-align:left">赋值变量</td></tr></tbody></table><h3 id="内建变量"><a href="#内建变量" class="headerlink" title="内建变量"></a>内建变量</h3><table><thead><tr><th>内建变量</th><th>描述</th></tr></thead><tbody><tr><td>FS (field separator)</td><td>输入字段分隔符(默认为空白)</td></tr><tr><td>RS (record separator)</td><td>输入记录分隔符(默认为换行)</td></tr><tr><td>OFS (output field separator)</td><td>输出字段分隔符(默认为空白)</td></tr><tr><td>ORS (output record sparator)</td><td>输出字段分割符</td></tr><tr><td>NF (number field)</td><td>字段数量</td></tr><tr><td>NR (number row)</td><td>行号(已经处理过的) 后面可跟多个文件</td></tr><tr><td>FNR (file number row)</td><td>行号(当前处理文件的) 后面可跟多个文件</td></tr><tr><td>ARGV (args value)</td><td>命令行参数的数组</td></tr><tr><td>ARGC(args count)</td><td>命令行参数(后跟的文件) 个数</td></tr></tbody></table><blockquote><p>例如 </p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root: ~]# awk 'BEGIN &#123;print ARGC,ARGV[0],ARGV[2]&#125;' /etc/fstab /etc/passwd</div><div class="line">3 awk /etc/passwd</div></pre></td></tr></table></figure><p>注意: 输入参数只有两个,但是显示3个,因为awk本身的命令也算一个 <code>ARGV[0]</code> 表示命令自身 <code>ARGV[2]</code>表示第二个</p><h3 id="格式化打印"><a href="#格式化打印" class="headerlink" title="格式化打印"></a>格式化打印</h3><blockquote><p>语法</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">printf "FORMAT", item1, item2, ...</div></pre></td></tr></table></figure><ul><li>必须要写FORMAT</li><li>不会自动换行,要手动加”\n”</li><li>FORMAT中需要分别为后面每个item指定格式符</li></ul><blockquote><p>格式符</p></blockquote><p>格式符:必须与 item 一一对应</p><table><thead><tr><th>个数符</th><th>含义</th></tr></thead><tbody><tr><td>%c</td><td>见一个数最ASCII字符显示</td></tr><tr><td>%d,%i</td><td>显示一个整数 %i 是十进制的</td></tr><tr><td>%e.%E</td><td>科学记数法显示</td></tr><tr><td>%f</td><td>显示为浮点数</td></tr><tr><td>%g,%G</td><td>以科学计数法或浮点形式显示数值</td></tr><tr><td>%s</td><td>显示字符串</td></tr><tr><td>%u</td><td>无符号整数</td></tr><tr><td>%%</td><td>显示%自身</td></tr></tbody></table><blockquote><p>修饰符</p></blockquote><p>控制显示的位宽,左对齐右对齐等等</p><table><thead><tr><th>修饰符</th><th>含义</th></tr></thead><tbody><tr><td>#[.#]</td><td>前面#表示位宽,后面表示输出的浮点型数字小数点后面的长度</td></tr><tr><td>-</td><td>左对齐,不写默认为右对其</td></tr><tr><td>+</td><td>显示数字的正负符号</td></tr></tbody></table><blockquote><p>例子</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root: ~]# awk -F : 'BEGIN&#123;printf "%-10s%-10s%-10s\n","username","uid","shell"&#125;'\</div><div class="line">'&#123;printf "%-10s%-10d%-10s\n",$1,$3,$NF&#125;' /etc/passwd</div><div class="line">username  uid       shell     </div><div class="line">root      0         /bin/bash </div><div class="line">bin       1         /sbin/nologin</div><div class="line">daemon    2         /sbin/nologin</div><div class="line">...</div></pre></td></tr></table></figure><p>注意: ‘BEGIN{action}’’{action}’ ,中间不能有空格,fomat格式化后面的字段,如果变量不加引号,字符串要加引号</p><h3 id="操作符"><a href="#操作符" class="headerlink" title="操作符"></a>操作符</h3><p>awk程序支持多种匹配模式来过滤数据记录,类似sed地址定界</p><blockquote><p>算术操作符</p></blockquote><p>跟其他变成语言类似注意次方的使用和bash的区别 <code>x^y</code> <code>x%y</code> </p><p>小技巧</p><p><code>+x</code> : 可以将某个字段转换成数字</p><p><code>-x</code> :转换成负数</p><blockquote><p>例如监控磁盘的使用率</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;root: ~&gt;# df | awk '&#123;if(+$5&gt;=10)printf"%-20s will full,used %-3s\n",$1,$5&#125;'</div><div class="line">/dev/mapper/cl-root  will full,used 22%</div><div class="line">/dev/sda1            will full,used 14%</div><div class="line">/dev/sdb1            will full,used 20%</div></pre></td></tr></table></figure><p><code>$5</code> 一列有个%号 使用 <code>+$5</code> 可以去掉%做数学运算,超过10%,报警</p><blockquote><p>赋值操作符</p></blockquote><p>都是如下表示方式 <code>++</code> <code>+=</code> 等</p><blockquote><p>模式匹配</p></blockquote><p>和bash scripts类似使用 <code>~</code> <code>!~</code> ,判断左边是否和右边匹配</p><blockquote><p>匹配行范围</p></blockquote><p>格式 : /part1/,/part2/  表示处理匹配/part1/ 到/part2/ 的之间所有行</p><p>注意:awk中不支持  3,8 这中行号的写法,真确的写法应该是 (NR&gt;=3&amp;&amp;NR&lt;=8)</p><blockquote><p>例子</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;root: ~&gt;# cat -n /etc/passwd | awk -F : '(NR&gt;=3&amp;&amp;NR&lt;=4)&#123;print $1,$3&#125;'</div><div class="line">     3daemon 2</div><div class="line">     4adm 3</div></pre></td></tr></table></figure><h3 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h3><h4 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h4><p>if 单分支: if (condition)  {statment1;stament2;…}</p><p>注意:如果只有一条命令,可以不用加花括号,否侧一定要加,且用分号隔开</p><p>多分支语法: if (condition) statement1;else statement2</p><blockquote><p>例如</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;root: ~&gt;# netstat -antu | awk '&#123;if($6=="LISTEN")&#123;x++&#125;else&#123;y++&#125;&#125;END&#123;print x,y&#125;'</div><div class="line">5 9</div></pre></td></tr></table></figure><p>表示: 处理每行的<code>$6</code> 如果为LISTEN 就执行x++, 执行完后执行END后的统计</p><p> 条件表达式(三目表达式) selector?if-true-expression1:if-false-expression2 </p><p>表示:selector 是否匹配,匹配的话继续匹配expression1否则继续匹配-expression2</p><blockquote><p>1 例如</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root: ~]# awk -F: '$3&gt;500?/\/bin\/bash$/:$3==0 &#123;print $0&#125;' /etc/passwd</div><div class="line">root:x:0:0:zhangxingshi,(0516)-5666123,18567087793,12344441113:/root:/bin/bash</div><div class="line">zxs:x:501:501::/home/zxs:/bin/bash</div><div class="line">zxs1:x:502:502::/home/zxs1:/bin/bash</div></pre></td></tr></table></figure><p>注意:/part/  part中的字符串有<code>/</code> 要转义</p><blockquote><p>例如</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root: ~]# awk -F: '&#123;$3&gt;499?usertype="common user":usertype="sysuser";printf "%10s:%-10s\n",$1,usertype&#125;' /etc/passwd</div><div class="line">      root:sysuser   </div><div class="line">       bin:sysuser   </div><div class="line">    daemon:sysuser   </div><div class="line">    ...</div></pre></td></tr></table></figure><h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><blockquote><p>语法</p></blockquote><p>1 while循环: while(condition){statement;…}</p><blockquote><p>例子</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;root: ~&gt;# awk '/^[[:space:]]*linux16/&#123;i=1;while(i&lt;=NF)&#123;print $i,length($i);i++&#125;&#125;'/etc/grub2.cfg</div></pre></td></tr></table></figure><p>表示: 查找 /etc/grub2.cfg 文件中匹配以空格后跟linux16的行,并统计每个字段的长度 <code>length()</code> 内建函数</p><p>2 for循环</p><p>语法 :  表达式一 :  for(expr1;expr2;expr3) {statement;…}   和c语言类似的语法</p><blockquote><p>例如 : 打印斐波那契数列</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[root: ~]# cat fibonacci.awk </div><div class="line"><span class="meta">#</span>!/bin/awk -f</div><div class="line">BEGIN&#123;</div><div class="line">    $1=1</div><div class="line">    $2=1</div><div class="line">    OFS=","</div><div class="line">    for(i=3;i&lt;=10;i++)</div><div class="line">    &#123;</div><div class="line">        $i=$(i-2)+$(i-1)</div><div class="line">    &#125;</div><div class="line">    print</div><div class="line">&#125;</div><div class="line">[root: ~]# ./fibonacci.awk </div><div class="line">1,1,2,3,5,8,13,21,34,55</div></pre></td></tr></table></figure><p>​        表达式二:  for(var in array) {for-body}   用于遍历数组: </p><h4 id="循环控制"><a href="#循环控制" class="headerlink" title="循环控制"></a>循环控制</h4><p>awk本身就是循环遍历,文件的每一行,然后进行处理. awk里的循环,一般循环的是字段</p><p>break 和 contine</p><p>例子: 计算100 奇数的和</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;root: ~&gt;# awk 'BEGIN&#123;sum=0;for(i=1;i&lt;=100;i++)&#123;if(i%2==0)continue;sum+=i&#125;print sum&#125;'</div><div class="line">2500</div></pre></td></tr></table></figure><p>next  : 表示提前结束本行的处理,对下一行进行循环. 看着和contine 差不多,但是next 跳过的是awk 自身对行的循环,而不是内部字段的循环</p><p>例如 </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;root: ~&gt;# awk -F : '&#123;if($3%2==0)next;print $1,$3&#125;' /etc/passwd</div><div class="line">bin 1</div><div class="line">adm 3</div><div class="line">...</div></pre></td></tr></table></figure><p>分析: <code>$3</code> 为uid 的字段,表示uid为偶数就 <code>next</code> 处理下一行, 结果为打印uid为奇数行的 1 3 字段 </p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>awk中的数组格式和bash中的关联数组类似,下标通常引用字段的名称,用于统计</p><ul><li>可使用任意字符串；字符串要使用双引号括起来</li><li>如果某数组元素事先不存在，在引用时，awk会自动创建此元素，并将其值初始化为“空串”</li><li>若要判断数组中是否存在某元素，要使用“var in array”格式进行遍历</li></ul><blockquote><p>例子1</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root: ~]# awk -F : '&#123;shell[$NF]++&#125;END&#123;for(i in shell)print i,shell[i]&#125;' /etc/passwd</div><div class="line">/sbin/shutdown 1</div><div class="line">/bin/bash 17</div><div class="line">/sbin/nologin 22</div><div class="line">/sbin/halt 1</div><div class="line">/bin/sync 1</div></pre></td></tr></table></figure><p>分析 :<code>shell</code> 是初始化的数组 <code>shell[$NF]++</code> 表示式中 <code>$NF</code>式文件中的shell类型,不同的shell 类型不同,数组的下标就不同,相同的下标值就会累加,最后统计</p><blockquote><p>例子 2</p></blockquote><p>要求统计测试文件test.txt 中分别男生和女生考试成绩的总成绩 和平均值</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">[root: ~]# cat test.txt </div><div class="line">mage 97 male</div><div class="line">wang 90 male</div><div class="line">zhang 80 female</div><div class="line">li  87 female</div><div class="line">[root: ~]# awk '&#123;sum[$3]+=$2;num[$3]++&#125;END&#123;for (i in sum) print i,sum[i],sum[i]/num[i] &#125;' test.txt </div><div class="line">female 167 83.5</div><div class="line">male 187 93.5</div></pre></td></tr></table></figure><p>分析: 本题初始两个数组 <code>sum</code> 和  <code>num</code> 下标都为 <code>$3</code> ,(就 male 和 female 两种) ,<code>sum[$3]</code>  累加 <code>$2</code> 表示同一个下标的总成绩, <code>num[$3]</code> 累加1 表示同一个下标出现的此时, 引用数组必须要用 <code>for (var in array)</code> 的形式, var 表示数组的下标 .</p><p>当然,如果统计某个字段的总类较多,适合用数组的表示方法. 本例中<code>$3</code> 字段中有两中,用 <code>if</code> 比较简单明了</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root: ~]# awk '&#123;if($3 == "male")&#123;msum+=$2;mnum++&#125;else&#123;fsum+=$2;fnum++&#125;&#125;END&#123;printf "male: %5-d%.1f\n",msum,msum/mnum;printf "female: %5-d%.1f\n",fsum,fsum/fnum&#125;' test.txt </div><div class="line">male: 187  93.5</div><div class="line">female: 167  83.5</div></pre></td></tr></table></figure><p>分析: 逻辑简单,需要四个变量,需要打印两次 ,所以需要 printf 换行,写法较乱</p><h3 id="内建函数"><a href="#内建函数" class="headerlink" title="内建函数"></a>内建函数</h3><h4 id="rand"><a href="#rand" class="headerlink" title="rand()"></a>rand()</h4><p>rand()：返回0和1之间一个随机数,不能直接调用 rand(),输出的值相同,需要使用srand(),并且通过运算获得想要的值的范围</p><blockquote><p>例如: 获取10个100以内的随机整数</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root: ~]# awk 'BEGIN&#123;srand();for(i=1;i&lt;=10;i++)print int(rand()*100)&#125;'</div></pre></td></tr></table></figure><h4 id="length"><a href="#length" class="headerlink" title="length()"></a>length()</h4><p>返回指定字符串的长度</p><h4 id="sub"><a href="#sub" class="headerlink" title="sub()"></a>sub()</h4><p>sub函数的参数格式为 <code>sub(r,s,[t])</code> 表示:对t字符串进行搜索r表示的模式匹配的内容，并将第一个匹配的内容替换为s</p><blockquote><p>例子</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root: ~]# date +"%F %T"</div><div class="line">2017-09-04 10:04:25</div><div class="line">[root: ~]# date +"%F %T" | awk 'sub(/:/,"-",$2)'</div><div class="line">2017-09-04 10-05:12</div></pre></td></tr></table></figure><p>注意 : <code>sub()</code>  默认值替换第一个匹配到的字符,全部替换要用 <code>gsub()</code></p><h4 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h4><p>参数格式为<code>split(s,array,[r])</code> 以r为分隔符，切割字符串s，并将切割后的结果保存至array所表示的数组中，第一个索引值为1,第二个索引值为2,…</p><blockquote><p>例如</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">&lt;root: ~&gt;# head -20 &lt;(awk  '&#123;print $5&#125;' f1.log) </div><div class="line">and</div><div class="line">Address</div><div class="line">172.18.5.67:38848</div><div class="line">172.18.5.67:38854</div><div class="line">172.18.5.67:38850</div></pre></td></tr></table></figure><p>如上文件<code>f1.log</code> 第5个字段是 ip:socket 的方式,要想在将 <code>$5</code> 切片成只剩ip 然后统计相同ip出现的次数 可以使用 <code>split()</code> </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">&lt;root: ~&gt;# awk  'NR&gt;2&#123;split($5,socket,":");ip[socket[1]]++&#125;END&#123;for (i in ip)print i,ip[i]&#125;' f1.log </div><div class="line"> 3</div><div class="line">0.0.0.0 2</div><div class="line">172.18.253.34 2</div><div class="line">172.18.5.67 4105</div></pre></td></tr></table></figure><p>分析 :<code>split()</code>  切片 <code>$5</code> 后保存在数组 <code>socket</code>  里 <code>socket[1]</code> 保存的是ip地址 ,然后再以 <code>socket[1]</code> 为下标</p><p>累加 <code>ip[socket[1]]++</code> ,取出 ip  数组的值和对应的下标就统计出来了</p><h3 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h3><p>在模式匹配中一般,关系表达是为真,才会处理,一般表示为,</p><blockquote><p>例如</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root: archive]# awk '!/^UUID/&#123;print $0&#125;' /etc/fstab</div><div class="line">[root: archive]# awk '!/^UUID/&#123;print&#125;' /etc/fstab</div><div class="line">[root: archive]# awk '!/^UUID/' /etc/fstab</div></pre></td></tr></table></figure><p>注意 : 以上三种表示方法的输出结果都一样, prinf 不加参数默认打印 <code>$0</code> ;{action} 不写默认动作为</p><p>{print $0} .</p><blockquote><p>还可以有一些奇葩方式</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root: archive]# seq 10 | awk 'i=!i'     #打印奇数行</div></pre></td></tr></table></figure><p>分析 :awk默认初始所有变量为 空或者0, (0表示假,表不不执行默认动作{print $0}) </p><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root: archive]# (seq 10;seq 10) | awk '!line[$0]++'</div></pre></td></tr></table></figure><p>分析: awk读取每行文件 ,<code>line[$0]</code> 初始值为0(即为假) <code>!line[$0]++</code>, <code>$0</code> 表示整行, 只要行不同,就是数组中的一个新的元素,初始值为 0 ,如果出现相同的行 <code>!line[$0]</code> 有值了即为假 ,不打印重复的行</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习:"></a>练习:</h3><blockquote><p> 统计/etc/init.d/functions 文件下的单词数</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">[root: ~]# cat word_count.awk </div><div class="line"><span class="meta">#</span>!/bin/awk -f</div><div class="line">BEGIN&#123;</div><div class="line">FS="[^a-zA-Z]+"</div><div class="line">printf "%-15s:%-5s\n---------------------\n","Word","Count"</div><div class="line">&#125;</div><div class="line">&#123;for(i=1;i&lt;=NF;i++)</div><div class="line">&#123;if( $i ~ /./ )</div><div class="line">&#123;word[$i]++</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">END&#123;for(j in word)</div><div class="line">&#123;printf "%-15s:%-5s\n",j,word[j]</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">[root: ~]# ./word_count.awk /etc/init.d/functions </div><div class="line">Word           :Count</div><div class="line">---------------------</div><div class="line">otherwise      :1    </div><div class="line">pidfileofproc  :2    </div><div class="line">...</div></pre></td></tr></table></figure><blockquote><p>提取出字符串Yd$C@M05MB%9&amp;Bdh7dq+YVixp3vpw中的所有数字</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root: ~]# echo "Yd$C@M05MB%9&amp;Bdh7dq+YVixp3vpw" | awk -F "" \</div><div class="line"><span class="meta">&gt;</span> '&#123; for (i=1;i&lt;+NF;i++)\</div><div class="line"><span class="meta">&gt;</span>      &#123; if ($i ~ /[0-9]/) printf $i&#125;\</div><div class="line"><span class="meta">&gt;</span> '&#125;</div></pre></td></tr></table></figure><p>注意: -F “” 表示以空为分隔符.表示每个字符算一个,字段</p><blockquote><p>合并相同列的两个文件</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;root: ~&gt;# cat f2.txt </div><div class="line">Number  score</div><div class="line">01      97</div><div class="line">02      56</div><div class="line">03      77</div><div class="line">&lt;root: ~&gt;# cat f1.txt </div><div class="line">Name  Number  Gendar</div><div class="line">zhang    01       M</div><div class="line">li       02       F</div><div class="line">wang     03       M</div><div class="line">&lt;root: ~&gt;# awk 'NR==FNR&#123;score[$1]=$2;next&#125;&#123;printf "%30-s%10-s\n",$0,score[$2]&#125;' f2.txt f1.txt </div><div class="line">Name  Number  Gendar          score     </div><div class="line">zhang    01       M           97        </div><div class="line">li       02       F           56        </div><div class="line">wang     03       M           77</div></pre></td></tr></table></figure><p>分析: 两个文件共同列是,<code>f2.txt</code> 中的 <code>$1</code> 和 <code>f1.txt</code> 中的 <code>$2</code> , 由于awk 处理两个文件 ,<code>NR==FNR</code> 表示的是第一个文件, 目的是将第一个文件的不同列合并到第二个文件里, 处理第一个文件是,不输出信息而是将 <code>$1</code> 当作下标 <code>$2</code> 当作值存储在 数组 score中, 处理到第二个文件时 直接打印 <code>$0</code> 和数组的值,注意下标为 这个文件的<code>$2</code>   </p>]]></content>
    
    <summary type="html">
    
      awk是一种模式扫描和处理语言，在对数据进行分析处理时，是十分强大的工具。
    
    </summary>
    
      <category term="linux基础" scheme="http://yoursite.com/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="awk" scheme="http://yoursite.com/tags/awk/"/>
    
  </entry>
  
  <entry>
    <title>bash变量高级用法</title>
    <link href="http://yoursite.com/2017/09/03/2017-09-03-bash/"/>
    <id>http://yoursite.com/2017/09/03/2017-09-03-bash/</id>
    <published>2017-09-02T16:00:00.000Z</published>
    <updated>2017-10-06T08:10:14.083Z</updated>
    
    <content type="html"><![CDATA[<h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>和普通变量不一样的,数组是多个元素的的连续的内存空间,相当与多个变量的集合.在一些脚本中需要定义一大堆变量是使用. 数组有两类 <code>索引数组</code> (下标为数字的就是索引数组) 和 <code>关联数组</code> (下标不为数字为自定义的字符串)</p><a id="more"></a><blockquote><p>声明/赋值/引用</p></blockquote><p><code>devlare -a ARRAY_NAME</code> 表示声明一个索引数组 ,可以不声明直接赋值</p><p><code>declare -A ARRAY_NAME</code> 表示声明一个关联数组 , 赋值前必须先声明</p><blockquote><p>索引数组赋值例如:</p></blockquote><p>语法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">name=(value1 value2 ... valueN)</div></pre></td></tr></table></figure><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">filename=(/etc/*)              # 其中() 内可以是任何命令生成的列表</div><div class="line">echo $&#123;filename[0]&#125;            # [0]  是引用第一个索引号的值</div><div class="line">echo $&#123;filename&#125;               # 不写下标默认引用第一个</div><div class="line">echo $&#123;#filename[*]&#125;           # 引用所有元素个数</div><div class="line">echo $&#123;!filename[*]&#125;           # 引用数组的所有下标</div></pre></td></tr></table></figure><p>注意:索引数组下标默认从0开始,所以最大的下标数为 所有数组元素个数-1</p><blockquote><p>关联数组赋值例如:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">declare -A week                                      # 关联数组赋值前必须声明,下标可自定义字符串</div><div class="line">week=([mon]=&quot;星期一&quot; [tue]=&quot;星期二&quot;  [wed]=&quot;星期三&quot;)   </div><div class="line">[root: ~]# echo $&#123;week[wed]&#125;                         # 引用单个下标的值</div><div class="line">星期三</div><div class="line">[root: ~]# echo $&#123;!week[*]&#125;                          # 引用所有下标</div><div class="line">mon tue wed</div><div class="line">[root: ~]# echo $&#123;week[*]&#125;                           # 引用所有下标的值</div><div class="line">星期一 星期二 星期三</div></pre></td></tr></table></figure><blockquote><p>应用数组脚本例子:</p></blockquote><p>冒泡排序: 随机生成一些数字然后排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">#!/bin/bash</div><div class="line">#</div><div class="line"># while flag=&quot;-gt&quot; find then max number from array ,else find min</div><div class="line">find_max () &#123;</div><div class="line">    for((j=$1;j&lt;$&#123;#rand[*]&#125;;j++)) ;do</div><div class="line">        [[ &quot;$2&quot; == &quot;-r&quot; ]] &amp;&amp; flag=-lt || flag=-gt</div><div class="line">        if [ $&#123;rand[$j]&#125; $flag $&#123;rand[$1]&#125; ];then</div><div class="line">            tmp=$&#123;rand[$1]&#125;</div><div class="line">            rand[$1]=$&#123;rand[$j]&#125;</div><div class="line">            rand[$j]=$tmp</div><div class="line">        fi</div><div class="line">    done</div><div class="line">&#125;</div><div class="line"># generate a array ( 15 numbers )</div><div class="line">declare -a rand</div><div class="line">for((i=0;i&lt;15;i++));do</div><div class="line">    rand[$i]=$RANDOM</div><div class="line">done</div><div class="line">echo &quot;random unmber:&quot;</div><div class="line">echo $&#123;rand[*]&#125;</div><div class="line"># sort the array from big to small</div><div class="line">bu_sort () &#123;</div><div class="line">    for((k=0;k&lt;$[$&#123;#rand[*]&#125;-1];k++));do</div><div class="line">        find_max $k $1</div><div class="line">    done</div><div class="line">    if [ -z &quot;$1&quot; ];then</div><div class="line">        echo &quot;sort form big to small:&quot;</div><div class="line">    else</div><div class="line">        echo &quot;sort from small to big:&quot;</div><div class="line">    fi</div><div class="line">    echo $&#123;rand[*]&#125;</div><div class="line">&#125;</div><div class="line">bu_sort</div><div class="line">bu_sort -r</div></pre></td></tr></table></figure><p>简单解析  <code>find_max ()</code> 函数的作用是找出最大值或最小值,与<code>$1</code>  互换值; <code>bu_sort ()</code> 循环传递参数给 <code>find_max()</code></p><p>以数组下标从小到大开始传递 </p><blockquote><p>执行效果如下:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root: archive]# bash bubble_sort.sh </div><div class="line">random unmber:</div><div class="line">11604 29655 24404 10818 4669 14564 14949 2907 31907 18988 12139 30330 119 12814 300</div><div class="line">sort form big to small:</div><div class="line">31907 30330 29655 24404 18988 14949 14564 12814 12139 11604 10818 4669 2907 300 119</div><div class="line">sort from small to big:</div><div class="line">119 300 2907 4669 10818 11604 12139 12814 14564 14949 18988 24404 29655 30330 31907</div></pre></td></tr></table></figure><h4 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h4><p>如果第一个变量的值是第二个变量的名字，从第一个变量引用第二个变量的值就称为间接变量引用</p><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root: ~]# name=zhang;age=20;gender=F</div><div class="line">[root: ~]# record=age             # 变量record的值age是里一个变量的变量名</div><div class="line">[root: ~]# echo $&#123;record&#125;         # 普通引用只能引用变量名</div><div class="line">age</div><div class="line">[root: ~]# echo $&#123;!record&#125;         # &quot;!&quot; 可以间接引用出age的值</div><div class="line">20</div></pre></td></tr></table></figure><p>注意:如果变量是数组<code>!</code> 引用的是数组的下标</p><blockquote><p>eval 命令</p></blockquote><p>eval命令将会首先扫描命令行进行所有的置换，然后再执行该命令。该命令适用于那些一次扫描无法实现其功能的变量.该命令对变量进行两次扫描</p><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root: ~]# eval echo \$$record</div><div class="line">20</div></pre></td></tr></table></figure><p>注: 在执行echo 命令之前eval 会先将命令行扫描一遍.将 <code>$record</code> 变成age ,由于<code>\$</code> 转义了,所有不会将认为后面的字符串为变量,eval扫描一遍后,显示的就是 <code>echo $age</code> , 当然eval 一般不会这么用</p><p>例如: <code>{1..$n}</code> 扩展中不支持使用变量,这是也已利用eval命令先扫描一遍,把变量变成值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">n=10;eval echo &#123;1..$n&#125;</div></pre></td></tr></table></figure><h4 id="按长度引用"><a href="#按长度引用" class="headerlink" title="按长度引用"></a>按长度引用</h4><blockquote><p>引用方法</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$&#123;var:offset:number&#125;      # offer表偏移量  ,numner表是取的个数</div></pre></td></tr></table></figure><blockquote><p>例子 ,这中用法不多,不多介绍</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root: ~]# var=abcdefghihk</div><div class="line">[root: ~]# echo $&#123;#var&#125;              #表示引用变量字符个数,和数组一样</div><div class="line">11</div><div class="line">[root: ~]# echo $&#123;var:2:3&#125;           #表示从左向右跳过2个字符,取三个字符</div><div class="line">cde</div></pre></td></tr></table></figure><h4 id="判断状态"><a href="#判断状态" class="headerlink" title="判断状态"></a>判断状态</h4><p>对于变量的状态(<code>set</code>或<code>unset</code>)和值是否为空(<code>null</code>)，bash提供四种方式扩展</p><p><code>${parameter:-word}</code> 如果变量状态为unset或值为空，返回<code>word</code>的结果值，否则返回变量的值。</p><p><code>${parameter:=word}</code> 如果变量状态为unset或值为空，<code>word</code>的结果会赋值给变量，然后返回变量值</p><p><code>${parameter:?word}</code> 如果变量状态为unset或值为空，<code>word</code>的结果值会被输出到标准错误，如果shell是非交互的(如脚本中)则退出(exit)；否则展开为变量的值。</p><p><code>${parameter:+word}</code> 如果变量状态为unset或值为空，什么也不返回，否则返回<code>word</code>的结果值。</p><p>注意:以上此种判断方式对于位置变量”<code>$1</code>  <code>$2</code>  等不能使用”</p><p>系统脚本中有很多这个写法,例如 <code>/etc/init.d/functions</code> 文件中有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Get a sane screen width</div><div class="line">[ -z &quot;$&#123;COLUMNS:-&#125;&quot; ] &amp;&amp; COLUMNS=80     # 表示COLUMNS变量空或unset状态就赋值为 80</div><div class="line">[ -z &quot;$&#123;CONSOLETYPE:-&#125;&quot; ] &amp;&amp; CONSOLETYPE=&quot;$(/sbin/consoletype)&quot;</div><div class="line">...</div></pre></td></tr></table></figure><h4 id="字符串切片"><a href="#字符串切片" class="headerlink" title="字符串切片"></a>字符串切片</h4><p>有如下几种表达方式:</p><p><code>${var#*word}</code>：从左向右配置第一个<code>word</code> 关键词,去掉word和word之前的字符</p><p><code>${var##*word}</code>: 从左向右配置最后一个<code>word</code> 关键词,去掉word和word之前的字符</p><p><code>${var%word*}</code>: 从右向左配置第一个<code>word</code> 关键词,去掉word和word之后的字符</p><p><code>${var%%word*}</code>:从右向左配置最后一个<code>word</code> 关键词,去掉word和word之后的字符</p><blockquote><p>例如</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">[root: ~]# url=https://zxslinux.github.io:80</div><div class="line">[root: ~]# echo $&#123;url##*/&#125;</div><div class="line">zxslinux.github.io:80</div><div class="line">[root: ~]# echo $&#123;url%:*&#125;</div><div class="line">https://zxslinux.github.io</div><div class="line">[root: ~]# echo $&#123;url%%:*&#125;</div><div class="line">https</div></pre></td></tr></table></figure><h4 id="查找替换"><a href="#查找替换" class="headerlink" title="查找替换"></a>查找替换</h4><blockquote><p>格式</p></blockquote><p><code>${var/pattern/substr}</code> ：查找var所表示的字符串中，第一次被pattern所匹配到的字符串，以substr替换之</p><p><code>${var//pattern/substr}</code> : 查找var所表示的字符串中，所有能被pattern所匹配到的字符串，以substr替换之</p><p><code>${var/#pattern/substr}</code> ：查找var所表示的字符串中，行首被pattern所匹配到的字符串，以substr替换之</p><p><code>${var/%pattern/substr}</code> ：查找var所表示的字符串中，行尾被pattern所匹配到的字符串，以substr替换之</p><blockquote><p>例子</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root: ~]# string=123456abcdef</div><div class="line">[root: ~]# echo $&#123;string/[0-9]/@&#125;           #只替换第一次匹配[0-9]的字符</div><div class="line">@23456abcdef</div><div class="line">[root: ~]# echo $&#123;string//[0-9]/@&#125;          #替换所有匹配[0-9]的字符</div><div class="line">@@@@@@abcdef</div><div class="line">[root: ~]# echo $&#123;string/#*6/@&#125;             #替换以&quot;*6&quot;开头的字符串为&quot;@&quot;</div><div class="line">@abcdef</div><div class="line">[root: ~]# echo $&#123;string/%c*/@&#125;             #替换以&quot;c*&quot;结尾的字符串为&quot;@&quot;</div><div class="line">123456ab@</div></pre></td></tr></table></figure><h4 id="大小写转换"><a href="#大小写转换" class="headerlink" title="大小写转换"></a>大小写转换</h4><p>表示方法有: <code>${var^}</code> ,<code>${var^^}</code> ,<code>${var,}</code>, <code>${var,,}</code></p><p>其中”^”: 表示转换首字符为大写, “^^” : 表示转换全部为大写.  相应的 “,” 表示转成小写 </p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;数组&quot;&gt;&lt;a href=&quot;#数组&quot; class=&quot;headerlink&quot; title=&quot;数组&quot;&gt;&lt;/a&gt;数组&lt;/h4&gt;&lt;p&gt;和普通变量不一样的,数组是多个元素的的连续的内存空间,相当与多个变量的集合.在一些脚本中需要定义一大堆变量是使用. 数组有两类 &lt;code&gt;索引数组&lt;/code&gt; (下标为数字的就是索引数组) 和 &lt;code&gt;关联数组&lt;/code&gt; (下标不为数字为自定义的字符串)&lt;/p&gt;
    
    </summary>
    
      <category term="shell脚本" scheme="http://yoursite.com/categories/shell%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="bash" scheme="http://yoursite.com/tags/bash/"/>
    
  </entry>
  
  <entry>
    <title>sellinux简单介绍</title>
    <link href="http://yoursite.com/2017/09/03/2017-09-03-selinux/"/>
    <id>http://yoursite.com/2017/09/03/2017-09-03-selinux/</id>
    <published>2017-09-02T16:00:00.000Z</published>
    <updated>2017-10-06T08:10:14.085Z</updated>
    
    <content type="html"><![CDATA[<h3 id="selinux概念"><a href="#selinux概念" class="headerlink" title="selinux概念"></a>selinux概念</h3><p>selinux(secure enhanced linux)是美国国家安全局(NSA=The National Security Agency)和SCC(SecureComputing Corporation)开发的 Linux的一个强制访问控制的安全模块。2000年以GNU GPL发布，Linux内核2.6版本后集成在内核中</p><a id="more"></a><p><code>DAC</code>：Discretionary Access Control自由访问控制</p><p><code>MAC</code>：Mandatory Access Control 强制访问控制</p><p>DAC环境下进程是无束缚的<br>MAC环境下策略的规则决定控制的严格程度<br>MAC环境下进程可以被限制的策略被用来定义被限制的进程能够使用那些资源（文件和端口）默认情况下，没有被明确允许的行为将被拒绝</p><h4 id="sellinux如何工作的"><a href="#sellinux如何工作的" class="headerlink" title="sellinux如何工作的"></a>sellinux如何工作的</h4><p>selinux也有安全上下文的概念,在sellinux眼中一切皆对象(文件,目录,进程,端口等)  ,在每个对象selinux中,都给对象的inode表中打上一个安全标签,并且限定某个进程只能某一类标签.标签有5类属性如下所示:</p><p>5类属性   user:role:type:sensitivity:category</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">system_u:object_r:admin_home_t:s0                # 最后一项一般不列出</div></pre></td></tr></table></figure><p><code>selinux期望安全向下文</code> :selinux对各种常用的进程服务都有限定访问那一类的安全标签,并将数据存储在自己的数据库中</p><blockquote><p>查看selinux数据中的定义</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">semanage fcontext –l      # 此工具由policycoreutils-python 程序包提供</div></pre></td></tr></table></figure><p><code>实际安全上下文</code> :实际的seinux安全上下文,是系统当前正在应用的安全标签</p><blockquote><p>查看文件安全标签</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;root: ~&gt;# ls -Z /root/.ssh/authorized_keys </div><div class="line">-rw-------. root root unconfined_u:object_r:ssh_home_t:s0 /root/.ssh/authorized_keys</div></pre></td></tr></table></figure><blockquote><p>查看进程的标签</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root: ~]# ps auxZ | grep httpd</div><div class="line">unconfined_u:system_r:httpd_t:s0 root      1869  0.0  0.7 175396  3792 ?        Ss   22:23   0:00 /usr/sbin/httpd</div></pre></td></tr></table></figure><p>当实际selinux安全上下文,不符合selinux数据库中的定义时,此时就会导致进程无法访问这个资源</p><h4 id="selinux工作类型"><a href="#selinux工作类型" class="headerlink" title="selinux工作类型"></a>selinux工作类型</h4><p>以下的类型不是所有的centos版本都有,默认都是用targert ,其他种类要么稳定要么被废弃了.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">centos 7 中 /etc/selinux/config 文件</div><div class="line"># SELINUXTYPE= can take one of three two values:</div><div class="line">#     targeted - Targeted processes are protected,</div><div class="line">#     minimum - Modification of targeted policy. Only selected processes are protected. </div><div class="line">#     mls - Multi Level Security protection.</div><div class="line">SELINUXTYPE=targeted</div></pre></td></tr></table></figure><ul><li>target:用来保护常见的网络服务,仅有限的进程受到selinux控制</li><li>strict :所有的进程都受selinux控制</li><li>minimum:(centos7 上有) 只限制自己选择的网络服务</li><li>mls:提供MLS(多级安全)机制的安全性</li></ul><h4 id="安全标签类型"><a href="#安全标签类型" class="headerlink" title="安全标签类型"></a>安全标签类型</h4><p><code>User</code> :指示登录系统的用户类型,如root,user_u,system_u,多数本地进程都属于自由（unconfined）进程</p><p><code>Role</code> :定义文件，进程和用户的用途：文件:object_r，进程和用户：system_r</p><p><code>Type</code> :指定数据类型，规则中定义何种进程类型访问何种文件Target策略基于type实现,多服务共用：public_content_t</p><p><code>Sensitivity</code> :限制访问的需要，由组织定义的分层安全级别，如unclassified, secret,top,secret, 一个对象有且只有一个sensitivity,分0-15级，s0最低,Target策略默认使用s0</p><p><code>Category</code>：对于特定组织划分不分层的分类，如FBI Secret，NSA secret, 一个对象可以有多个categroy， c0-c1023共1024个分类， Target 策略不使用category</p><h3 id="sellinux设置"><a href="#sellinux设置" class="headerlink" title="sellinux设置"></a>sellinux设置</h3><h4 id="启用selinux"><a href="#启用selinux" class="headerlink" title="启用selinux"></a>启用selinux</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">sed -i &apos;/^SELINUX=/c\SELINUX=enforcing&apos;  /etc/selinux/config        #修改配置文件</div><div class="line">setenforce 1|0                                                     #临时启用|禁用</div><div class="line">getenforce                                                         #查看当前状态</div><div class="line">sestatus                                                           #查看状态详情</div></pre></td></tr></table></figure><h4 id="给文件打标签"><a href="#给文件打标签" class="headerlink" title="给文件打标签"></a>给文件打标签</h4><blockquote><p>例如:  改变文件标签</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root: ~]# ls -Z /var/log/messages           # 查看文件类型为var_log_t</div><div class="line">-rw-------. root root system_u:object_r:var_log_t:s0   /var/log/messages </div><div class="line">[root: ~]# cp /var/log/messages /root/</div><div class="line">[root: ~]# ls -Z /root/messages              # cp不带选项复制会继承目标目录的安全标签</div><div class="line">-rw-------. root root unconfined_u:object_r:admin_home_t:s0 /root/messages</div><div class="line">[root: ~]# \mv /root/messages /var/log/messages       #强行覆盖原来的文件</div><div class="line">[root: ~]# ls -Z /var/log/messages                    #文件安全标签改变为admin_home_t</div><div class="line">-rw-------. root root unconfined_u:object_r:admin_home_t:s0 /var/log/messages</div><div class="line">[root: ~]# logger &quot;test log&quot;              # 测试能否写日志 ,查看已经无法写入</div></pre></td></tr></table></figure><blockquote><p>恢复文件标签</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[root: ~]# semanage fcontext -l | grep /var/log/messages        # 查看数据库中的 var_log_t</div><div class="line">/var/log/messages[^/]*     all files    system_u:object_r:var_log_t:s0 </div><div class="line">[root: ~]# chcon -t var_log_t /var/log/messages                 # 修改文件的安全标签类型</div><div class="line">[root: ~]# service rsyslog restart                              # 重启日志服务程序</div></pre></td></tr></table></figure><blockquote><p>添加安全标签</p></blockquote><p>例如: 创建站点目录 /www 让selinux限定不期望其他进程访问此目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root: /]# mkdir /www</div><div class="line">[root: /]# ls -dZ /www                  # 新建的文件默认安全标签为default_t</div><div class="line">drwxr-xr-x. root root unconfined_u:object_r:default_t:s0 /www </div><div class="line">[root: /]# fcontext -a -t httpd_sys_content_t &apos;/www(/.*)?&apos;           # 添加selinux数据库中的记录</div><div class="line">[root: /]# restorecon -R /www                                        # 恢复数据库的标签到目录</div></pre></td></tr></table></figure><blockquote><p>删除安全标签</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root: /]# semanage fcontext -d -t httpd_sys_content_t &apos;/www(/.*)?&apos;</div><div class="line">[root: /]# restorecon -R /www   #前面删除的是,数据库中的定义,实际文件标签并没有修改,要恢复同步到文件</div></pre></td></tr></table></figure><h4 id="给端口打标签"><a href="#给端口打标签" class="headerlink" title="给端口打标签"></a>给端口打标签</h4><p>在selinux启动的情况下,sshd程序想要修改自己监听端口,此时如果非标准端口不在selinux期望值内,会导致端口不可用.</p><p>例如: 修改sshd监听端口后,系统可能会报如下错误.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;root: ~&gt;# systemctl restart sshd</div><div class="line">Job for sshd.service failed because a configured resource limit was exceeded. See &quot;systemctl status sshd.service&quot; and &quot;journalctl -xe&quot; for details.</div></pre></td></tr></table></figure><blockquote><p>查看端口标签</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;root: ~&gt;# semanage port -l | grep ssh</div><div class="line">ssh_port_t                     tcp      22               # seliunx期望的sshd 监听端口为22</div></pre></td></tr></table></figure><blockquote><p>添加端口标签</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;root: ~&gt;# semanage port -a -t ssh_port_t -p tcp 2222      # 添加端口到selinux数据库中</div><div class="line">&lt;root: ~&gt;# semanage port -l | grep ssh</div><div class="line">ssh_port_t                     tcp      2222, 22</div><div class="line">&lt;root: ~&gt;# systemctl restart sshd      #此时重启就不会报错了</div></pre></td></tr></table></figure><blockquote><p>删除端口标签</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&lt;root: ~&gt;# semanage port -d -t ssh_port_t -p tcp 2222      # 还可以将2222的删除</div></pre></td></tr></table></figure><blockquote><p>修改端口标签</p></blockquote><p>注意: 修改sellinux端口标签不是,修改端口的值,而是将端口号,移动到给另一个进程使用,此端口必须存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;root: ~&gt;# semanage port -m -t ssh_port_t -p tcp 3389     # 将3389移动到 ssh监听 显示端口没定义</div><div class="line">ValueError: Port @tcp/3389 is not defined</div><div class="line">&lt;root: ~&gt;# semanage port -m -t http_port_t -p tcp 2222    # 表示将2222端口移动给http进程监听</div></pre></td></tr></table></figure><h4 id="selinux布尔值"><a href="#selinux布尔值" class="headerlink" title="selinux布尔值"></a>selinux布尔值</h4><p>selinux定义了很多规则,认为危险的行为,都禁用了</p><blockquote><p>查看selinux的布尔值</p></blockquote><p><code>getsebool</code> :查看简要bool信息 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;root: ~&gt;# getsebool -a | grep http   </div><div class="line">httpd_anon_write --&gt; off      # selinux认为httpd匿名可写是危险的行为,默认禁用了</div></pre></td></tr></table></figure><p><code>semanage boolean -l</code> : 列出详细的描述信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;root: ~&gt;# semanage boolean -l | grep httpd</div><div class="line">SELinux boolean                State  Default Description</div><div class="line">httpd_can_network_relay        (off  ,  off)  Allow httpd to can network relay</div></pre></td></tr></table></figure><p><code>State</code> :表示当前的状态,当前生效的</p><p><code>Default</code> 表示默认在selinux数据库中的策略,重启后生效</p><blockquote><p>设置 bool值命令</p></blockquote><p>有两种设置方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">setsebool [-P] boolean value（on,off）     -p : 表示 state和defaut 连个状态都开,不加表示只开 state</div><div class="line">setsebool [-P] Boolean=value（0，1）</div></pre></td></tr></table></figure><p>例如:允许httpd家目录共享功能设置, httpd中<code>UserDir disabled</code> 指令</p><p>注意:httpd程序自己也有控制访问的设置, 要想真正启用此功能,必须要在httpd配置文件中修改后,还要开启sellinux的控制,这里仅仅是开启selinux的设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">&lt;root: ~&gt;# getsebool -a | grep &quot;http.*dir&quot;          # 查到设置项的名称</div><div class="line">httpd_dontaudit_search_dirs --&gt; off</div><div class="line">httpd_enable_homedirs --&gt; off</div><div class="line">&lt;root: ~&gt;# setsebool -P httpd_enable_homedirs on    # 设置为启用httpd_enable_homedirs 为on</div></pre></td></tr></table></figure><p>selinux日志管理</p><p>selinux的日志管理需要安装一个软件包  <code>setroubleshoot</code>  重启后才能生效</p><p>selinux会将错误日志写入/var/log/messages 中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root: ~]# tail /var/log/messages</div><div class="line">Sep  2 02:43:04 localhost setroubleshoot: SELinux is preventing /usr/sbin/httpd from getattr access on the file /var/www/html/index.html. For complete SELinux messages. run sealert -l cdcbb123-0bf1-478e-aaba-7b9f0148ab53</div></pre></td></tr></table></figure><p>注意: selinux写入/var/log/messages 的日志非常简单,但是指示了 运行 <code>sealert -l cdcbb123-0bf1-478e-aaba-7b9f0148ab53</code> 查看详细内容, 后面是日志id号,</p><p>当日志为太多运行grep命令查找关键词setroubleshoot  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grep setroubleshoot  /var/log/messages</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;selinux概念&quot;&gt;&lt;a href=&quot;#selinux概念&quot; class=&quot;headerlink&quot; title=&quot;selinux概念&quot;&gt;&lt;/a&gt;selinux概念&lt;/h3&gt;&lt;p&gt;selinux(secure enhanced linux)是美国国家安全局(NSA=The National Security Agency)和SCC(SecureComputing Corporation)开发的 Linux的一个强制访问控制的安全模块。2000年以GNU GPL发布，Linux内核2.6版本后集成在内核中&lt;/p&gt;
    
    </summary>
    
      <category term="安全" scheme="http://yoursite.com/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="semanage" scheme="http://yoursite.com/tags/semanage/"/>
    
  </entry>
  
  <entry>
    <title>进程管理</title>
    <link href="http://yoursite.com/2017/08/24/2017-08-24-proc/"/>
    <id>http://yoursite.com/2017/08/24/2017-08-24-proc/</id>
    <published>2017-08-23T16:00:00.000Z</published>
    <updated>2017-10-06T08:10:14.081Z</updated>
    
    <content type="html"><![CDATA[<h3 id="linux进程管理"><a href="#linux进程管理" class="headerlink" title="linux进程管理"></a>linux进程管理</h3><p>操作系统的内存空间,简单可以认为分用户空间和内核空间,内核负责管理分配内存.在单个进程看来整个内存中只有自己和内核存在.内核总通过维护一张数据结构<code>task structure</code>的表,记录包括进程id,进程的父子进程id,程序运行到哪个阶段,内存地址真正指向物理内存的位置等等.</p><a id="more"></a><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p><code>线性地址空间</code>:内核虚拟出一段连续的内存,在物理内存中不是连续的</p><p><code>物理地址空间</code>:实际硬件的的地址</p><p><code>保存现场</code>:多个进程在用户看来是同时运行的,但在cpu看来,同一个时间点只有一个程序在运行,cpu是将自己的计算能力,按时间分成时间片(毫秒级的),每个程序在cpu上运行一段时间如果程序还没有运行完,内核不能让进程一直占用cpu,这个让进程下去,并保存进程运行到那个阶段,这个过程叫做保存现场.</p><p><code>恢复现场</code>:内核调用之前没有运行完的程序,会查记录这个程序之前运行到那个阶段,并恢复后让程序从之前断开的地方继续进行.</p><p><code>context switch</code>:多个进程和内核来回切换到cpu上运行</p><p><code>task structure</code>:任务结构,保存了各个进程的相关信息</p><p><code>process</code>:被调到内存和cpu上运行的程序</p><p><code>thread</code> :比进程更小的单位,一个进程只能运行在cpu的一个核上,如果一个比较复杂的进程中一些任务可以互补依赖的独立运行就将这个进程分成多个线程,让他们能运行在不同的cpu上且共享内存空间,避免浪费.</p><p><code>CoW</code> :写时复制 Copy only Write 创建Fork()  复制Clone(),一种进程创建子进程的机制</p><p><code>Big O</code>:描述程序运行消耗的时间和处理数据大小的关系</p><p>如下图是进程内存中的图:<br>    <img src="http://47.91.157.219/images/memory.png" alt="image"></p><p><code>Page Frame</code>:类似逻辑卷中的PE,指线性内存中的最小单位4K</p><p><code>LRU</code>: Least Recentlly Used 近期最少使用算法,内存是有限的,内核将最近<br>使用最小的进程剔除释放内存,提供给新的进程使用,缓存也是用相同的算法</p><p><code>MMU</code>: Memory Management Unit 内存管理单元,内核的功能,内核将物理内存虚拟层可连续<br>可扩展的线性内存提供的给进程使用,它维护了一张虚拟内存和物理内存的对应关系的表</p><p><code>TLB</code>:Translation Lookaside Buffer 翻译后备缓冲器,用于保存虚拟地址和物理地址映射关系的缓存,主要为了加快速度,避免每次<br>都要去查找MMU中的记录</p><p><code>IPC</code>:Inter Process Communication,进程间的通信</p><blockquote><p>进程在同一个主机上的通信机制:</p></blockquote><ol><li>signal</li></ol><p><code>kill -l</code> , <code>trap -l</code> 可以查看centos信号的种类,运维人员必须要的到的有</p><pre><code>1) SIGHUP          #通知进程不重启从读配置文件2) SIGINT          #中断,类似中断下crtl+c9) SIGKILL         #强制程序终止,相当与直接拔电源那种15) SIGTERM        #关闭进程,通知进程正常关闭一些自己正在操作的文件</code></pre><ol><li><p>shm:shared memory  共享内存,一个进程加工出来好数据后给里一个进程使用</p></li><li><p>semaphore ,多线程模型中控制线程合理使用公共资源的东西,运维不用了解太深.</p></li></ol><blockquote><p>进程在不同主机上的通信机制</p></blockquote><p><code>rpc</code>:Remote Procedure Call  远程过程调用 例如 <code>NFS</code>(linux主机中共享文件的一个服务)</p><p><code>socket</code>: IP和端口号 利用tcp/udp协议</p><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>命令<code>top</code>可以查看所有的进程的状态信息<br><img src="http://47.91.157.219/images/top1.png" alt="image"></p><p>如图: 1核的cpu下,绝大部为情况下,看到<code>running</code> 的数量都是1,表示了一个进程只能在一个,cpu上允许,大多数都是处于休眠态</p><ol><li><p>运行态:running</p></li><li><p>就绪态:ready</p></li><li><p>睡眠态</p></li></ol><h3 id="程序管理命令"><a href="#程序管理命令" class="headerlink" title="程序管理命令"></a>程序管理命令</h3><h4 id="查看进程ps命令"><a href="#查看进程ps命令" class="headerlink" title="查看进程ps命令"></a>查看进程ps命令</h4><p>ps有两种显示风格(早期UNIX的两大分支 system V 和 BSD)</p><blockquote><p>BSD风格 (选项不带”-“)</p></blockquote><p>a       :显示所有跟终端有关的进程</p><p>x        :显示所有跟终端无关的进程</p><p>u        :显示发起进程的用户和其他一些字段</p><p>f       :显示父子进程关系</p><p>o         :显示指定的字段逗号分开<br>        pid、comm、%cpu、%mem、state、tty、euser(effict user)、ruser(realuser)..</p><p>-C  conmand  :显示指定命令的进程相关信息</p><p>常用组合</p><pre><code>ps aux                               # 显示所有的进程包括跟终端有关和无关的ps axo user,pid,comm...              # 只显示指定的字段,</code></pre><blockquote><p>system V 风格</p></blockquote><pre><code>ps -ef         #f显示的内容比较全面类似 ps aux</code></pre><blockquote><p>ps aux显示字段含义</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[root: ~]# ps aux</div><div class="line">USER        PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</div><div class="line">root          1  0.0  0.3  19356  1548 ?        Ss   00:22   0:01 /sbin/init</div><div class="line">root          2  0.0  0.0      0     0 ?        S    00:22   0:00 [kthreadd]</div><div class="line">root          3  0.0  0.0      0     0 ?        S    00:22   0:00 [migration/0]</div><div class="line">root          4  0.0  0.0      0     0 ?        S    00:22   0:00 [ksoftirqd/0]</div><div class="line">root          5  0.0  0.0      0     0 ?        S    00:22   0:00 [stopper/0]</div><div class="line">root          6  0.0  0.0      0     0 ?        S    00:22   0:00 [watchdog/0]</div><div class="line">root          7  0.1  0.0      0     0 ?        R    00:22   0:39 [events/0]</div></pre></td></tr></table></figure><p><code>%CPU</code>:占用cpu的百分比</p><p><code>%MEM</code>:占用内存的百分比</p><p><code>TIME</code>:指在cpu上运行的时间总和,休眠状态不算在内</p><p><code>VSZ</code>: Virtual memory SiZe，虚拟内存集，线性内存</p><p><code>RSS</code>: ReSident Size, 常驻内存集</p><p><code>[.*]</code>: 中括号表示内核进程</p><p><code>STAT</code>：进程状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">R：running</div><div class="line">S: interruptable sleeping</div><div class="line">D: uninterruptable sleeping</div><div class="line">T: stopped</div><div class="line">Z: zombie</div><div class="line">+: 前台进程</div><div class="line">l: 多线程进程</div><div class="line">L：内存分页并带锁</div><div class="line">N：低优先级进程</div><div class="line">&lt;: 高优先级进程</div><div class="line">s: session leader，会话（子进程）发起者</div></pre></td></tr></table></figure><h4 id="优先级命令"><a href="#优先级命令" class="headerlink" title="优先级命令"></a>优先级命令</h4><p>静态优先级：100-139,<br>进程默认启动时的nice值为0，优先级为120,<br>只有根用户才能降低nice值（提高优先性）.</p><blockquote><p>调整已经启动的进程</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">renice -10 PID</div></pre></td></tr></table></figure><blockquote><p>启动是调整优先级nice</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nice -n -10 vim f1</div></pre></td></tr></table></figure><h4 id="搜索进程命令pgreg"><a href="#搜索进程命令pgreg" class="headerlink" title="搜索进程命令pgreg"></a>搜索进程命令pgreg</h4><blockquote><p>语法:pgrep [options] pattern</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-u euid: effective user，生效者</div><div class="line">-U uid: real user，真正发起运行命令者</div><div class="line">-t terminal: 与指定终端相关的进程</div><div class="line">-l: 显示进程名</div><div class="line">-a: 显示完整格式的进程名</div><div class="line">-P pid: 显示指定进程的子进程</div></pre></td></tr></table></figure><blockquote><p>语法:pidof PNAME<br>根据进程名查找pid,可用于判断进程是否启动,适用于脚本</p></blockquote><h4 id="查看系统运行-负载时间uptime"><a href="#查看系统运行-负载时间uptime" class="headerlink" title="查看系统运行,负载时间uptime"></a>查看系统运行,负载时间uptime</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root: ~]# uptime</div><div class="line"> 10:46:12 up 10:23,  2 users,  load average: 0.00, 0.00, 0.00</div></pre></td></tr></table></figure><p>每列分别表示 :</p><p>当前时间 运行时间   上线人数     每1,5,10 分钟平均内进程队列长度 (平均负载)</p><p>平均负载可与判断系统当前的繁忙程度</p><p>如果linux主机是1个双核CPU，如果load average每项的指标都是在1以上,就代表cpu一直在处理<br>事务,因为1表示后面还有1个进程在排队,如果几个指标一直处于5,那就要赶紧查查是怎么回事了,cpu已经忙不过来了</p><blockquote><p>动态查看系统性能top</p></blockquote><p>   <img src="http://47.91.157.219/images/top2.png" alt="image">        </p><p>栏位信息简介</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">us：用户空间</div><div class="line">sy：内核空间</div><div class="line">ni：调整nice时间</div><div class="line">id：空闲</div><div class="line">wa：等待IO时间</div><div class="line">hi：硬中断</div><div class="line">si：软中断（模式切换）</div><div class="line">st：虚拟机偷走的时间</div></pre></td></tr></table></figure><p>top 命令时交互命令默认每三秒刷新一次,排序为cpu从高到低</p><blockquote><p>改变排序：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">P：以占据的CPU百分比,%CPU </div><div class="line">M：占据内存百分比,%MEM </div><div class="line">T：累积占据CPU时长,TIME+</div></pre></td></tr></table></figure><h4 id="内存监控工具"><a href="#内存监控工具" class="headerlink" title="内存监控工具"></a>内存监控工具</h4><p>语法 vmstat [options] [delay [count]]            </p><p>vmstat 不加任何选项默认只显示一次<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vmstat 2 5       #每2秒刷新一次一共刷5次</div></pre></td></tr></table></figure></p><blockquote><p>vmstat输出结果显示</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&lt;root: ~&gt;# vmstat 2</div><div class="line">procs -----------memory---------- ---swap-- -----io---- -system-- ------cpu-----</div><div class="line"> r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa st</div><div class="line"> 2  0      0 228472    948 170956    0    0     6     1  187   62  0  0 100  0  0</div><div class="line"> 0  0      0 228456    948 170956    0    0     0     0  438   36  0  0 100  0  0</div><div class="line"> 0  0      0 215200    948 170992    0    0     0     0  396   82  1  2 97  0  0</div><div class="line"> 0  0      0 215200    948 170992    0    0     0     0  438   61  0  1 99  0  0</div></pre></td></tr></table></figure><p>procs:</p><p><code>r</code>：可运行（正运行或等待运行）进程的个数，和核心数有关</p><p><code>b</code>：处于不可中断睡眠态的进程个数(被阻塞的队列的长度)</p><p>memory：</p><p><code>swpd</code>: 交换内存的使用总量</p><p><code>free</code>：空闲物理内存总量</p><p><code>buffer</code>：用于buffer的内存总量</p><p><code>cache</code>：用于cache的内存总量</p><p>swap:</p><p><code>si</code>：从磁盘交换进内存的数据速率(kb/s)</p><p><code>so</code>：从内存交换至磁盘的数据速率(kb/s)</p><p><code>io</code>：</p><p><code>bi</code>：从块设备读入数据到系统的速率(kb/s)</p><p><code>bo</code>: 保存数据至块设备的速率</p><p>system：</p><p><code>in</code>: interrupts 中断速率，包括时钟</p><p><code>cs</code>: context switch 进程切换速率</p><p>cpu：</p><p><code>us</code>:Time spent running non-kernel code</p><p><code>sy</code>: Time spent running kernel code</p><p><code>id</code>: Time spent idle. Linux 2.5.41前,包括IO-wait time.</p><p><code>wa</code>: Time spent waiting for IO. 2.5.41前，包括in idle.</p><p><code>st</code>: Time stolen from a virtual machine. 2.6.11前, unknown.</p><p>注意:si,so,bi,bo 是以物理内存为参考,描述input和output</p><p>dstat命令：系统资源统计,代替vmstat,iostat</p><p>不加任何选项下默认会不停的刷新输出</p><p>语法: dstat [-afv] [options..] [delay [count]]</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">-c: 显示cpu相关信息</div><div class="line">-C #,#,...,total</div><div class="line">-d: 显示disk相关信息</div><div class="line">-D total,sda,sdb,...</div><div class="line">-g：显示page相关统计数据</div><div class="line">-m: 显示memory相关统计数据</div><div class="line">-n: 显示network相关统计数据</div><div class="line">-p: 显示process相关统计数据</div><div class="line">-r: 显示io请求相关的统计数据</div><div class="line">-s: 显示swapped相关的统计数据</div><div class="line">--top-cpu：显示最占用CPU的进程</div><div class="line">--top-io: 显示最占用io的进程</div><div class="line">--top-mem: 显示最占用内存的进程</div><div class="line">--top-latency: 显示延迟最大的进程</div></pre></td></tr></table></figure><h4 id="kill命令"><a href="#kill命令" class="headerlink" title="kill命令"></a>kill命令</h4><p>kill,pkill,killall</p><blockquote><p>按PID：kill [-SIGNAL] pid …</p><p>按名称：killall [-SIGNAL] comm…</p><p>按模式：pkill [options] pattern</p></blockquote><p>-u uid: effective user，生效者</p><p>-U uid: real user，真正发起运行命令者</p><p>-t terminal: 与指定终端相关的进程</p><p>-l: 显示进程名（pgrep可用）</p><p>-a: 显示完整格式的进程名（pgrep可用）</p><p>-P pid: 显示指定进程的子进</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;linux进程管理&quot;&gt;&lt;a href=&quot;#linux进程管理&quot; class=&quot;headerlink&quot; title=&quot;linux进程管理&quot;&gt;&lt;/a&gt;linux进程管理&lt;/h3&gt;&lt;p&gt;操作系统的内存空间,简单可以认为分用户空间和内核空间,内核负责管理分配内存.在单个进程看来整个内存中只有自己和内核存在.内核总通过维护一张数据结构&lt;code&gt;task structure&lt;/code&gt;的表,记录包括进程id,进程的父子进程id,程序运行到哪个阶段,内存地址真正指向物理内存的位置等等.&lt;/p&gt;
    
    </summary>
    
      <category term="linux基础" scheme="http://yoursite.com/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ps" scheme="http://yoursite.com/tags/ps/"/>
    
      <category term="top" scheme="http://yoursite.com/tags/top/"/>
    
  </entry>
  
  <entry>
    <title>centos7,nmcli工具</title>
    <link href="http://yoursite.com/2017/08/22/2017-08-22-nmcli/"/>
    <id>http://yoursite.com/2017/08/22/2017-08-22-nmcli/</id>
    <published>2017-08-21T16:00:00.000Z</published>
    <updated>2017-10-06T08:10:14.079Z</updated>
    
    <content type="html"><![CDATA[<h2 id="nmcli简介"><a href="#nmcli简介" class="headerlink" title="nmcli简介"></a>nmcli简介</h2><p>nmcli (NetworManager Client),是NetworkManager的程序的客户端,需要安装并启动服务进程.<br>nmccli 工具集子命令,异常的多.好在centos7,支持子命令补全功能,需要安装<code>bash-completion</code><br>软件包,安装好后 <code>su -</code> 重新重新初始下工作环境就可以生效了</p><a id="more"></a><h3 id="centos7网卡命令方式"><a href="#centos7网卡命令方式" class="headerlink" title="centos7网卡命令方式"></a>centos7网卡命令方式</h3><p>centos6之前采用的是传统的网卡命名方式eth[#],当增加删除网卡的时候网卡名可能会随之改变.</p><p>centos7采用systemd通过识别硬件和设备类型进行命名.</p><h3 id="修改centos网卡名称"><a href="#修改centos网卡名称" class="headerlink" title="修改centos网卡名称"></a>修改centos网卡名称</h3><p>修改centos网卡命名方式为centos6之前的命名方式,要修改<code>/boot/grub2/grub.cfg</code>的文件,的内核启动选项,添加 <code>net.ifname=0</code> 如下图:</p><p>不过官方不建议用户手动修改此文件,因为改错了,可能会导致grub程序出错导致系统无法启动,</p><p>较为安全的做法是</p><p>1.修改<code>/etc/default/grub</code> 中添加net.ifname=0 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">GRUB_CMDLINE_LINUX=&quot;crashkernel=auto rd.lvm.lv=cl/root rd.lvm.lv=cl/swap rhgb quiet net.ifname=0&quot;</div></pre></td></tr></table></figure><p><img src="http://47.91.157.219/images/grub2.png" alt="image"></p><p>2.grub2-mkconfig -o /etc/grub2.cfg</p><p>3.重启系统</p><p>注意:此时重启系统后,用ifconfig 查看网卡名后变成了eth0,eth1  但是网卡配置文件的文件名,和网卡配置文件中的 <code>DEVICE=,  NAME=</code> 没有修改,需要编辑修改.</p><h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><pre><code>nmcli [ OPTIONS ] OBJECT { COMMAND | help }</code></pre><p>OBJECT 为对象常用的也就两个</p><p><code>device</code>  类似ip link 的link,对接口进行操作,偏向物理层</p><p><code>connect</code> 类似ip addr 的addr,对地址属性进行操作,偏向逻辑层</p><h4 id="网络地址配置管理"><a href="#网络地址配置管理" class="headerlink" title="网络地址配置管理"></a>网络地址配置管理</h4><blockquote><p>查看所有链接</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nmcli connection [ show ]     #show不加也可以 connection 也可以简写为 con 或 c</div></pre></td></tr></table></figure><blockquote><p>查看特定接口的详细信息</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nmcli connection show eth0     #显示内容非常详细</div></pre></td></tr></table></figure><blockquote><p>查看设备的状态</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nmcli device show eth0</div></pre></td></tr></table></figure><blockquote><p>启动关闭重新加载某个接口</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nmcli connection &#123;up|reload|down&#125; ens33</div></pre></td></tr></table></figure><blockquote><p>命令行修改网卡名称 modify</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nmcli connection modify ens37 connection.id eth1</div></pre></td></tr></table></figure><p>注意:此命令只是改配置文件中NAME= 的值及时生效</p><blockquote><p>添加网卡配置文件 add</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nmcli connection add con-name home-eth1 type ethernet ifname eth1</div></pre></td></tr></table></figure><p>注意:给网卡添加一个配置文件,不同场景下可以随机切花配置,此时会生成另一个配置文件,默认使用dhcp获取ip地址</p><blockquote><p>修改属性手动配置ip </p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nmcli connection modify home-eth1 ipv4.method manual ipv4.addresses 9.9.9.9/8 ipv4.gateway 9.9.9.1 ipv4.dns 114.114.114.114</div></pre></td></tr></table></figure><blockquote><p>modify 子命令和配置文件中的对应关系如下表</p></blockquote><table><thead><tr><th>子命令</th><th>配置文件字段</th></tr></thead><tbody><tr><td> ipv4.method</td><td>BOOTPROTO=none</td></tr><tr><td> ipv4.method auto</td><td>BOOTPROTO=dhcp</td></tr><tr><td>ipv4.addresses</td><td>IPADDR=,PREFIX=</td></tr><tr><td>pv4.dns 8.8.8.8</td><td>DNS0=8.8.8.8</td></tr><tr><td>ipv4.dns-search</td><td>example.com DOMAIN=example.com</td></tr><tr><td>ipv4.ignore-auto-dns true</td><td>PEERDNS=no</td></tr><tr><td>connection.autoconnect yes</td><td>ONBOOT=yes</td></tr><tr><td>connection.id eth0</td><td>NAME=eth0</td></tr><tr><td>connection.interface-name</td><td>eth0 </td></tr></tbody></table><h3 id="nmcli配置bond"><a href="#nmcli配置bond" class="headerlink" title="nmcli配置bond"></a>nmcli配置bond</h3><blockquote><p>bonding机制</p></blockquote><p>就是将多块网卡绑定同一IP地址对外提供服务，可以实现高可用或者负载均衡。当然，直接给两块网卡设置同一IP地址是不可能的。通过bonding，虚拟块网卡对外提供连接，物理网卡的被修改为相同的MAC地址。</p><blockquote><p>bondding模式常用种类如下</p></blockquote><table><thead><tr><th>MODE</th><th>NAME</th><th>Destination</th></tr></thead><tbody><tr><td> 0</td><td>balance-rr</td><td>多个网卡同时工作,提供负载均衡和容错的能力</td></tr><tr><td> 1</td><td>active-backup</td><td>主从模式,从的充当备胎角色,冗余的设计</td></tr><tr><td> 3</td><td>broadcast</td><td>这种模式所有数据包都会接受两份,避免丢包</td></tr></tbody></table><blockquote><p>操作如下</p></blockquote><ol><li>添加mybond0</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nmcli connection add type bond con-name mybond0 ifname mybond0 modeactive-backup</div></pre></td></tr></table></figure><ol><li>修改mybond0网络设置</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nmcli connection modify mybond0 ipv4.method manual ipv4.addresses172.18.5.70 ipv4.gateway 172.18.0.1 ipv4.dns 172.18.0.1</div></pre></td></tr></table></figure><ol><li>添加两个网卡到mybond0里</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nmcli connection add type bond-slave master mybond0 ifname ech0</div><div class="line">nmcli connection add type bond-slave master mybond0 ifname ech1</div></pre></td></tr></table></figure><p>4 .启动从属网卡</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nmcli connection up bond-slave-eth0</div><div class="line">nmcli connection up bond-slave-eth1</div></pre></td></tr></table></figure><ol><li>可能需要重启服务</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">systemctl restart network</div></pre></td></tr></table></figure><h3 id="nmcli配置team"><a href="#nmcli配置team" class="headerlink" title="nmcli配置team"></a>nmcli配置team</h3><p>team和bond原理一样,只是team采用的技术比较先进,<br>team不同于旧版中bonding技术，提供更好的性能和扩展性<br>team中提供的模式有</p><p><code>broadcast</code><br><code>roundrobin</code><br><code>active-backup</code><br><code>loadbalance</code><br><code>lacp</code></p><p>有一部分和bond是相同的bond是在 <code>mode</code> 关键词后指定 team是在 <code>config</code> 关键词后指定</p><p>team的config后模式和bond相比有较大的不同,具体为JSON样式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">&apos;&#123;&quot;runner&quot;: &#123;&quot;name&quot;: &quot;METHOD&quot;&#125;&#125;&apos;</div></pre></td></tr></table></figure><p>注意:<code>runner</code> 和 <code>name</code> 为关键词不用改 METHOD 为想要指定的模式种类,<code>broadcase</code> <code>actibe-back</code> <code>roundrobin</code> 等</p><p>1.添加网络组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nmcli connection add type team con-name team0 ifname team0 config &apos;&#123;&quot;runner&quot;:&#123;&quot;name&quot;:&quot;loadbalance&quot;&#125;&#125;&apos;</div></pre></td></tr></table></figure><p>小技巧:这个命令比较复杂,如果没有明显的语法错误,系统不会报错,这个时候要<code>nmcli connection show</code> 查看所有的连接情况</p><p>绿色的表示成功并且已经启用</p><p>白色表示要么被down掉了,要么不生效</p><p>黄色表示就绪状态,可以启用</p><p><img src="http://47.91.157.219/images/team.png" alt="image"></p><ol><li>修改组的网络配置为静态IP</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nmcli connection modify team0 ipv4.method manual ipv4.addresses 172.18.5.70 ipv4.gateway 172.18.0.1 ipv4.dns 172.18.0.1</div></pre></td></tr></table></figure><ol><li>加入物理网卡到team0组里</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nmcli connection add type team-slave master team0 ifname eth0</div><div class="line">nmcli connection add type team-slave master team0 ifname eth1</div></pre></td></tr></table></figure><ol><li>启动</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nmcli connection up team0</div><div class="line">nmcli connection up team-slave-eth0</div><div class="line">nmcli connection up team-slave-eth1</div></pre></td></tr></table></figure><h3 id="nmcli配置bridge"><a href="#nmcli配置bridge" class="headerlink" title="nmcli配置bridge"></a>nmcli配置bridge</h3><p>多网卡桥接功能,不提供冗余和负载均衡的能力,主要用于虚拟化中,功能也是将多个网卡绑定到一个IP地址中.</p><p>添加桥接br0        </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nmcli connection add type bridge con-name br0 ifname br0</div></pre></td></tr></table></figure><p>添加属于br0接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nmcli connection add type bridge-slave master br0 ifname eth0</div><div class="line">nmcli connection add type bridge-slave master br0 ifname eth1</div></pre></td></tr></table></figure><p>修改br0地址为静态地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">nmcli connection modify br0 ipv4.method manual ipv4.addresses 172.18.5.70/16 ipv4.gateway 172.18.0.1 ipv4.dns 172.18.0.1</div></pre></td></tr></table></figure><p>启动br0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">nmcli connection up br0</div><div class="line">nmcli connection up bridge-slave-eth0</div><div class="line">nmcli connection up bridge-slave-eth1</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;nmcli简介&quot;&gt;&lt;a href=&quot;#nmcli简介&quot; class=&quot;headerlink&quot; title=&quot;nmcli简介&quot;&gt;&lt;/a&gt;nmcli简介&lt;/h2&gt;&lt;p&gt;nmcli (NetworManager Client),是NetworkManager的程序的客户端,需要安装并启动服务进程.&lt;br&gt;nmccli 工具集子命令,异常的多.好在centos7,支持子命令补全功能,需要安装&lt;code&gt;bash-completion&lt;/code&gt;&lt;br&gt;软件包,安装好后 &lt;code&gt;su -&lt;/code&gt; 重新重新初始下工作环境就可以生效了&lt;/p&gt;
    
    </summary>
    
      <category term="网络管理" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="nmcli" scheme="http://yoursite.com/tags/nmcli/"/>
    
  </entry>
  
  <entry>
    <title>搭建简单路由器实验</title>
    <link href="http://yoursite.com/2017/08/20/2017-08-20-route/"/>
    <id>http://yoursite.com/2017/08/20/2017-08-20-route/</id>
    <published>2017-08-19T16:00:00.000Z</published>
    <updated>2017-10-06T08:10:14.076Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实验原理"><a href="#实验原理" class="headerlink" title="实验原理"></a>实验原理</h3><p>路由器交换机的本质上也是一台linux系统的服务器,只不过是专门高度定制只用来做路由<br>功能,centos系列系统支持路由转发,只是默认没有开启.只要修改内核参数<code>/proc/sys/net/ipv4/ip_foward=1</code> 在加上几个网卡就能当路由器用了.</p><a id="more"></a><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><p>让172.18.5.0/16网段的linux客户端机器经过三个路由,ping通192.168.100.0/24的windous XP客户端主机.<br>练习centos6,7 网络配置命令,熟悉基本网络原理</p><h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><blockquote><p>网络拓扑图结构如下</p></blockquote><p><img src="http://47.91.157.219/images/router.png" alt="image"></p><h4 id="VMware虚拟机"><a href="#VMware虚拟机" class="headerlink" title="VMware虚拟机"></a>VMware虚拟机</h4><blockquote><p>新建5个虚拟机,其中三个至少要有两给我网卡做路由</p></blockquote><p><img src="http://47.91.157.219/images/vm1.png" alt="image"></p><blockquote><p>虚拟机创建三个虚拟网络</p></blockquote><p><img src="http://47.91.157.219/images/vm2.png" alt="image"></p><table><thead><tr><th>名称</th><th>网段</th></tr></thead><tbody><tr><td>VMware2</td><td>192.168.0.0/24</td></tr><tr><td>VMware3</td><td>192.168.150.0/24</td></tr><tr><td>VMware4</td><td>192.168.100.0/24</td></tr><tr><td>桥接网络</td><td>172.18.0.0/16</td></tr></tbody></table><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><h4 id="命令行修改IP地址设置"><a href="#命令行修改IP地址设置" class="headerlink" title="命令行修改IP地址设置"></a>命令行修改IP地址设置</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ip addr add 172.18.5.1/16 dev eth0</div><div class="line">ip addr add 192.168.0.254/24 dev eth1</div></pre></td></tr></table></figure><p>router不需要配置网关,待会会配置静态路由表,要想永久生效需要写入配置文件</p><h4 id="网卡eth0配置文件"><a href="#网卡eth0配置文件" class="headerlink" title="网卡eth0配置文件"></a>网卡eth0配置文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">DEVICE=eth0</div><div class="line">HWADDR=00:0C:29:A8:DC:BF</div><div class="line">TYPE=Ethernet</div><div class="line">UUID=852c7033-2683-4bf7-ab62-980a1b17680b</div><div class="line">ONBOOT=yes</div><div class="line">NM_CONTROLLED=yes</div><div class="line">BOOTPROTO=none</div><div class="line">IPADDR=172.18.5.1</div><div class="line">PREFIX=16</div></pre></td></tr></table></figure><blockquote><p>网卡eth1配置文件</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">DEVICE=eth1</div><div class="line">HWADDR=00:0C:29:A8:DC:C9</div><div class="line">TYPE=Ethernet</div><div class="line">UUID=6e42bc6c-cf3f-4f24-8b30-263c915750b5</div><div class="line">ONBOOT=yes</div><div class="line">NM_CONTROLLED=yes</div><div class="line">BOOTPROTO=none</div><div class="line">IPADDR=192.168.0.254</div><div class="line">PREFIX=24</div></pre></td></tr></table></figure><h4 id="添加静态了路由"><a href="#添加静态了路由" class="headerlink" title="添加静态了路由"></a>添加静态了路由</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ip route add 192.168.100.0/24 via 192.168.0.128 dev eth1</div><div class="line">ip route add 192.168.50.0/24 via 192.168.0.128 dev eth1</div></pre></td></tr></table></figure><p>或者直接写为一条默认记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ip route add default  via 192.168.0.128 dev  eth1</div></pre></td></tr></table></figure><p>==同样静态路由表要想永久生效需要写入配置文件==</p><p>centos6 系统事先并不存在 静态路由表的配置文件需要自己手动创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">echo &quot;0.0.0.0/0  via   192.168.0.128&quot;  &gt;&gt; /etc/sysconfig/network-scripts/route-eth1</div></pre></td></tr></table></figure><h4 id="开启路由转发功能"><a href="#开启路由转发功能" class="headerlink" title="开启路由转发功能"></a>开启路由转发功能</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cat /proc/sys/net/ipv4/ip_forward               #0表示不器用</div><div class="line">echo 1 &gt; /proc/sys/net/ipv4/ip_forward</div></pre></td></tr></table></figure><h4 id="内核参数配置文件"><a href="#内核参数配置文件" class="headerlink" title="内核参数配置文件"></a>内核参数配置文件</h4><p>/etc/sysctl.cfg这个使系统内核参数的配置文件,系统开机内核会读取此文件的配置信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">...</div><div class="line"># Controls IP packet forwarding</div><div class="line">net.ipv4.ip_forward = 0              #修改此项为1后保持退出</div><div class="line">...</div></pre></td></tr></table></figure><p>通知内核重读配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sysctl -p</div></pre></td></tr></table></figure><blockquote><p>测试centos客户端,和R1的是否通</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">ip route add default via 172.18.5.1     # 先把网关指向R1</div><div class="line">ping 192.168.0.254</div></pre></td></tr></table></figure><p>R2和R3的配置过程和上面一样,这里就不重复了,列出网卡的配置信息和路由表的信息</p><blockquote><p>R2的IP,route表的配置信息</p></blockquote><table><thead><tr><th>网卡名</th><th>VMnet</th><th>ip</th><th>route</th></tr></thead><tbody><tr><td>ens32</td><td>192.168.0.0/24</td><td>192.168.0.128</td><td>172.18.0.0/16 via 192.168.0.254</td></tr><tr><td>ens33</td><td>192.168.50.0/24</td><td>192.168.50.128</td><td>192.168.100.0/24 via 192.168.50.254</td></tr></tbody></table><blockquote><p>R3的IP,route表的配置信息</p></blockquote><table><thead><tr><th>网卡名</th><th>VMnet</th><th>ip</th><th>route</th></tr></thead><tbody><tr><td>ens32</td><td>192.168.50.0/24</td><td>192.168.50.254</td><td>0.0.0.0/0 via 192.168.50.128</td></tr><tr><td>ens33</td><td>192.168.100.0/24</td><td>192.168.100.254</td><td>无</td></tr></tbody></table><blockquote><p>windous XP ip配置为 192.168.100.2  网关指向R3的 192.168.100.254</p></blockquote><p><img src="http://47.91.157.219/images/xp.png" alt="image"></p><blockquote><p>测试ping通后追踪路由表看下</p></blockquote><p><img src="http://47.91.157.219/images/xp.route.png" alt="image"></p><p>可以看到依次次经过了三个路由到达目标主机.</p><p><img src="http://47.91.157.219/images/linux.route.png" alt="image"></p><p>windosXP追踪linux的客户端可以,linux追踪windosXP貌似不能,不知道什么原因</p><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>1 由于实验室虚拟机模拟,要看清MAC地址和网卡名对应</p><p>2 centos7下的<code>/etc/sysctl.conf</code>配置文件,没有配置信息了,只剩一堆提示信息,直接追加 net.ipv4.ip_forward=1 也是可一永久生效的</p><p>3 centso6下如果不是最小化安装,可以会有一个服务程序<code>NetworkManager</code>,这个程序在centos6上有问题,强烈建议停掉这个服务器程序</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;实验原理&quot;&gt;&lt;a href=&quot;#实验原理&quot; class=&quot;headerlink&quot; title=&quot;实验原理&quot;&gt;&lt;/a&gt;实验原理&lt;/h3&gt;&lt;p&gt;路由器交换机的本质上也是一台linux系统的服务器,只不过是专门高度定制只用来做路由&lt;br&gt;功能,centos系列系统支持路由转发,只是默认没有开启.只要修改内核参数&lt;code&gt;/proc/sys/net/ipv4/ip_foward=1&lt;/code&gt; 在加上几个网卡就能当路由器用了.&lt;/p&gt;
    
    </summary>
    
      <category term="网络管理" scheme="http://yoursite.com/categories/%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="ip" scheme="http://yoursite.com/tags/ip/"/>
    
      <category term="ifconfig" scheme="http://yoursite.com/tags/ifconfig/"/>
    
  </entry>
  
  <entry>
    <title>简单制作centos6自动安装iso镜像</title>
    <link href="http://yoursite.com/2017/08/12/2017-08-12-mkiso/"/>
    <id>http://yoursite.com/2017/08/12/2017-08-12-mkiso/</id>
    <published>2017-08-11T16:00:00.000Z</published>
    <updated>2017-10-06T08:10:14.074Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简单原理"><a href="#简单原理" class="headerlink" title="简单原理"></a>简单原理</h2><p>将centos iso镜像文件挂载复制到目录下展开，加入用kickstart生成的自动应答文件 <code>ks.cfg</code> ，导入到镜像文件中，再用光盘制作脚本制作成ISO镜像文件。</p><a id="more"></a><h2 id="准备工具"><a href="#准备工具" class="headerlink" title="准备工具"></a>准备工具</h2><ul><li>mkdvdiso.sh脚本</li><li>centos6 cd1，cd2</li><li>kickstart 软件</li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="获取镜像文件"><a href="#获取镜像文件" class="headerlink" title="获取镜像文件"></a>获取镜像文件</h3><p>下载CD1和CD2 两个一起下</p><p>阿里云开源镜像站 <a href="https://mirrors.aliyun.com/centos/6.9/isos/x86_64/" target="_blank" rel="external">https://mirrors.aliyun.com/centos/6.9/isos/x86_64/</a></p><p><em>注：阿里云镜像站，镜像不全，只保留一个大版本的最新版本，例如centos6只有6.9 centos5只有5.11</em></p><p>centos官方社区 <a href="https://wiki.centos.org/Download" target="_blank" rel="external">https://wiki.centos.org/Download</a><br><em>注：版本齐全，重2.1~7.3都有，由于网站在国外比较慢</em></p><h3 id="合并CD1和CD2"><a href="#合并CD1和CD2" class="headerlink" title="合并CD1和CD2"></a>合并CD1和CD2</h3><blockquote><p>挂载光盘并复制合并镜像文件</p></blockquote><pre><code>cd /misc/cd       cp -r /misc/cd /root/data/ISO</code></pre><p><em>由于我安装了autofs软件，可以实现自动挂载，没有就手动挂载，复制镜像</em></p><p><em>iso镜像文件下有两个隐藏文件<code>.discinfo</code>  <code>.treeinfo</code>，也要复制过去`cp/musc/cd/</em>` 这个命令不会复制隐藏文件,直接复制目录改名即可*</p><blockquote><p>换CD2光盘复制镜像</p></blockquote><p>CD2 中的光盘跟CD1其他文件都一样，只是CD2有写额外的软件包，只复制rpm包即可</p><pre><code>cp -r /misc/cd/Packages/*.rpm /root/data/ISO/Packages/</code></pre><h3 id="制作kickstart文件"><a href="#制作kickstart文件" class="headerlink" title="制作kickstart文件"></a>制作kickstart文件</h3><p>kickstart制作工具，安装的是图像界面的，所有系统要先安装下图像桌面</p><h4 id="安装kickstart"><a href="#安装kickstart" class="headerlink" title="安装kickstart"></a>安装kickstart</h4><pre><code>yum install -y system-config-kickstart.noarch</code></pre><h4 id="图像界面下启动kickstart"><a href="#图像界面下启动kickstart" class="headerlink" title="图像界面下启动kickstart"></a>图像界面下启动kickstart</h4><p>kickstart图像界面跟安装界面差不多，配置很简单</p><p>图片中没有选定选项，可根据自己需要修改</p><blockquote><p>设置语言，键盘，时区，Root密码，安装完毕后重启等</p></blockquote><p><img src="http://47.91.157.219/images/ks/2017-08-12-ks.png" alt="基本配置"></p><blockquote><p>设置安装方式CD-ROM</p></blockquote><p><img src="http://47.91.157.219/images/ks/2017-08-12-ks2.png" alt="安装方法"></p><blockquote><p>安装MBR</p></blockquote><p><img src="http://47.91.157.219/images/ks/2017-08-12-ks3.png" alt="引导选项"></p><blockquote><p>自定义分区设置</p></blockquote><p><img src="http://47.91.157.219/images/ks/2017-08-12-ks4.png" alt="安装方法"></p><blockquote><p>网卡配置</p></blockquote><p><img src="http://47.91.157.219/images/ks/2017-08-12-ks5.png" alt="安装方法"></p><blockquote><p>是否启用防火墙和sellinux</p></blockquote><p><img src="http://47.91.157.219/images/ks/2017-08-12-ks6.png" alt="安装方法"></p><blockquote><p>是否安装图像环境</p></blockquote><p><img src="http://47.91.157.219/images/ks/2017-08-12-ks7.png" alt="安装方法"></p><blockquote><p>选择软件包</p></blockquote><p><img src="http://47.91.157.219/images/ks/2017-08-12-ks8.png" alt="安装方法"></p><blockquote><p>安装后运行的脚本</p></blockquote><p><img src="http://47.91.157.219/images/ks/2017-08-12-ks9.png" alt="安装方法"></p><blockquote><p>保存至光盘目录下的isolinux 目录下文件命令了ks.cfg</p></blockquote><p><img src="http://47.91.157.219/images/ks/2017-08-12-ks10.png" alt="安装方法"></p><h4 id="修改镜像引导菜单的配置文件"><a href="#修改镜像引导菜单的配置文件" class="headerlink" title="修改镜像引导菜单的配置文件"></a>修改镜像引导菜单的配置文件</h4><blockquote><p>合并后的文件大小大约为5.8G centos6.9CD1+CD2</p></blockquote><pre><code> [root: ISO]# du -sh .5.8G</code></pre><blockquote><p>修改引导菜单的配置文件</p></blockquote><pre><code>[root: ISO]# vim isolinux/isolinux.cfg ...18 label linux 19   menu label ^Install or upgrade an existing system 20   menu default                                             #超时后默认启动的项21   kernel vmlinuz22   append initrd=initrd.img 23 label vesa 24   menu label Install system with ^basic video driver 25   kernel vmlinuz 26   append initrd=initrd.img nomodeset27 label rescue 28   menu label ^Rescue installed system 29   kernel vmlinuz 30   append initrd=initrd.img rescue...</code></pre><p><em>只是简单列出一部分，这个就是安装的时候选项菜单，自己照范本新建一个或者直接改。但是要指定<code>ks.cfg</code>的路径</em></p><pre><code>23 label autoinstall                                                 #指定标签 24   menu label auto Install system with ^auto install newsystem     #自己随便写 25   kernel vmlinuz 26   append initrd=initrd.img ks=cdrom:/isolinux/ks.cfg              #ks文件路径一定要指明</code></pre><h4 id="最后将这个目录做成ISO镜像"><a href="#最后将这个目录做成ISO镜像" class="headerlink" title="最后将这个目录做成ISO镜像"></a>最后将这个目录做成ISO镜像</h4><p>centos系统有个命令能将光盘制作成ISO镜像， <code>mkisofs</code> 但是这个命令做出来iso镜像无法引导，centos官方提供了一个基于这个命令的脚本</p><p><a href="https://wiki.centos.org/TipsAndTricks/CDtoDVDMedia" target="_blank" rel="external">https://wiki.centos.org/TipsAndTricks/CDtoDVDMedia</a></p><p>脚本如下图，复制粘贴到一个文件中，文件名为<code>mkdvdiso.sh</code> 方便识别</p><p><img src="http://47.91.157.219/images/ks/2017-08-12-iso.png" alt="安装方法"></p><p>用法，脚本有介绍</p><pre><code>[root: ~]# bash mkdvdiso.sh -hUsage: mkdvdiso.sh source /destination/DVD.isoThe &apos;source&apos; can be either a directory containing a singleset of isos, or an exploded tree like an ftp site.</code></pre><blockquote><p>具体做法</p></blockquote><pre><code>bash mkdvdiso /root/centos6.9-64-auto.iso /root/data/ISO        只指明的iso文件名，和源镜像文件的目录即可</code></pre><p>等待完成光盘就做好了</p>]]></content>
    
    <summary type="html">
    
      linxu系统上，简单理解文件和目录的存储方式，从根本上理解软连接和硬链接
    
    </summary>
    
      <category term="自动化运维" scheme="http://yoursite.com/categories/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%BF%90%E7%BB%B4/"/>
    
    
      <category term="mkdvdiso.sh" scheme="http://yoursite.com/tags/mkdvdiso-sh/"/>
    
  </entry>
  
  <entry>
    <title>磁盘管理</title>
    <link href="http://yoursite.com/2017/08/12/2017-08-12-disk/"/>
    <id>http://yoursite.com/2017/08/12/2017-08-12-disk/</id>
    <published>2017-08-11T16:00:00.000Z</published>
    <updated>2017-10-06T08:10:14.071Z</updated>
    
    <content type="html"><![CDATA[<h2 id="磁盘结构"><a href="#磁盘结构" class="headerlink" title="磁盘结构"></a>磁盘结构</h2><p>机械硬盘（HDD）：Hard Disk Drive，即是传统普通硬盘，主要由：盘片，磁头，盘片转轴及控制电机，磁头控制器，数据转换器，接口，缓存等几个部分组成.固态硬盘（SSD）：Solid State Drive，用固态电子存储芯片阵列而制成的硬盘，由控制单元和存储单元（FLASH芯片、DRAM芯片）组成。</p><a id="more"></a><blockquote><p>相关术语</p></blockquote><p>fdisk -l 显示系统上所有磁盘的信息（centos6）</p><pre><code>Disk /dev/sda: 42.9 GB, 42949672960 bytes255 heads, 63 sectors/track, 5221 cylindersUnits = cylinders of 16065 * 512 = 8225280 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk identifier: 0x000595b3...</code></pre><p><code>CHS</code>:(Cylinder Head Sector) 早期的磁盘结构 24bit寻址方式 8bit Head 6bit sectoes/track 10bit cylinder 最大支持8G=2^6<em>2^8^210</em>512bit</p><p><code>LBA</code>:(logical Black Addressing) 通过转换成CHS格式完成磁盘具体寻址 48个bit位寻址 最大支持128PB</p><p>fdisk -l /dev/sda (centos 7)</p><pre><code>[root@localhost fd]# fdisk -l /dev/sdaDisk /dev/sda: 107.4 GB, 107374182400 bytes, 209715200 sectorsUnits = sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisk label type: dosDisk identifier: 0x0002e74b    </code></pre><p><em>现在centos7 中淡化了传统的柱面磁道磁头的表示方式，直接显示一块磁盘上总共有多少个扇区，总共大小为<br>209715200 sectors </em> 512bit*</p><p><code>head</code>：磁头的数量(8bit寻址) 0-255 现在显示都是255 最大了</p><p><code>sectors/track</code>：每个磁道有的扇区数（6bit 寻址）0-63 显示为63 最大了,物理结构最小单位为扇区固定大小为 512bit</p><p><code>cylinders</code>：柱面CHS磁盘结构 （10bit 寻址） 0-1024，现在都超了，也不是采用这种划分方法</p><p><code>BIOS</code>Basic Input Output System，固化到主板芯片上的一段程序，</p><p><code>UEFI</code>Unified Extensible Firmware Interface，比传统的BIOS先进，不能加载MBR分区的硬盘</p><h2 id="分区类型"><a href="#分区类型" class="headerlink" title="分区类型"></a>分区类型</h2><blockquote><p><code>MBR</code>：Master Boot Record  主引导记录</p></blockquote><p>MBR，使用的的32位寻址方式，最多只能表示2^32个扇区，最大支持的硬盘大小为 2^32*512bit=2T</p><p>MBR的分区方式，第0磁道0扇区中存放了重要的信息，一个扇区512bit</p><ul><li>前446bit ，是BootLoader的引导程序</li><li>中间64bit，是分区的信息没16个表示一个分区，最多支持4个分区</li><li><p>最后2bit，55aa （十六进制） 有表示硬盘是否有分区</p><p><code>hexdump -C -n 512 /dev/sda</code> 命令可以查看磁盘前512个字节的内容（16进制显示）</p></li></ul><blockquote><p><code>GPT</code>：Globals Unique Identifiers</p></blockquote><p>使用128位UUID(Universally Unique Identifier) 表示磁盘和分区 GPT分区表自动备份在头和尾两份，并有CRC校验位。超出2T的硬盘只能用此分区结构。而且用这种结构的硬盘启动操作系统要配合，UEFI BIOS不能识别这种分区，</p><h2 id="管理分区"><a href="#管理分区" class="headerlink" title="管理分区"></a>管理分区</h2><p>centos系统分区工具为，fdisk，gdisk，lsblk，parted</p><blockquote><p>lsblk  列举出系统上的所有的磁盘</p></blockquote><pre><code>lsblk -f           # 显示区各个分区对应的文件系统</code></pre><p>虚拟机中添加scsi磁盘，系统不能马上识别，通知系统扫描磁盘</p><pre><code>echo &quot;- - -&quot; &gt; /sys/class/scsi_host/host0/scan     #什么原理不知道</code></pre><h3 id="创建分区命令"><a href="#创建分区命令" class="headerlink" title="创建分区命令"></a>创建分区命令</h3><h4 id="fdisk"><a href="#fdisk" class="headerlink" title="fdisk"></a>fdisk</h4><blockquote><p>用法</p></blockquote><p>fdisk [device]</p><p>fdisk 只能用作MBR类的分区结构</p><pre><code>n  创建新分区d  删除分区t  修改分区类型,83默认 82是swap 8e是LVMl  查看分区类型的ID              w  保存q  不保存m  查看帮助p  查看分区信息</code></pre><h4 id="parted"><a href="#parted" class="headerlink" title="parted"></a>parted</h4><blockquote><p>用法 </p></blockquote><p>有交互式和命令式，高级装b工具。可以在脚本中避免交互，可以对gpt和mbr支持，操作实时生效，非常危险只做简要介绍</p><pre><code>parted /dev/sdc mklabel gpt               #指定分区结构parted /dev/sdc mkpart primary 1 2000     #指定主分区 1到2000 默认M为单位parted /dev/sdc print                     #列出所有的分区parted /dev/sdc rm 1                      #删除编号为1的分区</code></pre><p><code>mklabel</code>：表示创建为什么类型的分区<code>msdos</code>表示mbr，<code>gpt</code>就是gpt</p><p><code>mkpart</code>：表示创建分区，1 ext2 2000 表示1M开始2000M结束，格式化为ext2，文件系统。最好不要用parted格式化分区，貌似支持的文件系统不是很多</p><h4 id="gdisk"><a href="#gdisk" class="headerlink" title="gdisk"></a>gdisk</h4><p>gpt专用的分区工具，和fdisk非常相似，但是一旦使用这个工具，即使是msdos结构的分区，也会变成gpt的</p><h4 id="通知内核重读分区表"><a href="#通知内核重读分区表" class="headerlink" title="通知内核重读分区表"></a>通知内核重读分区表</h4><p>分区表有两份，内存中一分，硬盘上一份，<br>注意<code>lsblk</code>,<code>df``cat /proc/partitions</code>命令查看的都是内存中的映射，fdisk ，gdisk -l命令查看的是磁盘上实时的分区表</p><blockquote><p>通知内核重读分区表命令</p></blockquote><pre><code>partprobe /dev/sdc              #不接参数表示重读全部分区</code></pre><p><em>注意：centos6系统上用此命令有bug，这个命令在centos5，7上表现不错</em> 报错信息如下</p><pre><code>partprobe Warning: WARNING: the kernel failed to re-read the partition table on /dev/sd(Device or resource busy).  As a result, it may not reflect all of your changes until after reboot.</code></pre><blockquote><p>centos6 上正确的姿势为</p></blockquote><pre><code>partx [选项] /dev/sdc</code></pre><p>[选项]</p><p><code>-a</code>：对磁盘进行增加分区的时候操作</p><p><code>-d</code>：对磁盘删除单个分区的时候操作</p><p><code>--nr M-N</code>:对多个分区同时删除的时候操作</p><h2 id="管理文件系统"><a href="#管理文件系统" class="headerlink" title="管理文件系统"></a>管理文件系统</h2><h3 id="文件系统的类型"><a href="#文件系统的类型" class="headerlink" title="文件系统的类型"></a>文件系统的类型</h3><p>centos能够识别很多的文件系统，文件系统之上还有一层VFS抹合和各个文件系统之间的不同，和NTFS的windos不一样</p><ul><li>linux：文件系统  ext2（无journal功能）,3,4  xfs  reiserfs  btrfs</li><li>光盘：iso9660</li><li>网络文件系统: nfs cifs</li><li>集群文件系统：gfs2  ocfs2</li><li>内核文件系统: ceph</li><li>windows: vfat ntfs</li><li>伪文件系统： /sys  /proc  /devpts</li><li>Unix文件系统：</li><li>交换文件系统：swap</li><li>用户空间分布式文件系统：</li></ul><p>支持文件系统需要内核已经将对应的系统模块加载进来，路径在</p><pre><code>ls /lib/modules/`uname -r`/kernel/fs</code></pre><p>查看系统支持的文件系统类型</p><pre><code>cat /proc/filesystems</code></pre><h3 id="格式化创建文件系统"><a href="#格式化创建文件系统" class="headerlink" title="格式化创建文件系统"></a>格式化创建文件系统</h3><blockquote><p>mkfs 系列命令 </p></blockquote><pre><code>&lt;root: ~&gt;# mkfsmkfs          mkfs.ext2     mkfs.ext4     mkfs.msdos    mkfs.cramfs   mkfs.ext3     mkfs.ext4dev  mkfs.vfat</code></pre><blockquote><p>用法</p></blockquote><p>直接后跟分区就行</p><pre><code>&lt;root: ~&gt;# mkfs.ext4  /dev/sdb1mke2fs 1.41.12 (17-May-2010)         #此类命令都是调用mke2fs文件系统 Filesystem label=</code></pre><blockquote><p>mke2fs命令功能强</p></blockquote><p>mke2fs只支持ext系列文件系统的文件系统创建</p><p>mke2fs  [选项]  {partition}</p><blockquote><p>选项</p></blockquote><p><code>-t</code> {ext2|ext3|ext4}  指明创建的文件系统</p><p><code>-b</code> {1024|2048|4096}  块大小</p><p><code>-L</code> LABEL: 指明卷标</p><p><code>-j</code>：创建有日志功能的文件系统</p><p><code>-i</code>：每多少字节创建一个inode</p><p><code>-N</code>: 直接指明给文件系统创建inode数量</p><p><code>-O[^]</code> : 创建文件系统是启用或关闭一种特性</p><p><code>-m</code>：指定预留的空间 5% 默认</p><p><em>注意：物理磁盘机构中最小的单位为<code>sector</code>固定大小为512byte，存储的最小单位为字节1byte，文件系统最小的存储单位为<code>block</code>（不能小于物理结构512byte，实际为1024-4096之间）</em></p><p>inode为文件的索引表，尾部是指针指向占据的磁盘块，所以inode不得小于磁盘块数</p><p>mke2fs 命令只支持ext系列的文件系统，centos7 默认使用的xfs文件系统，要使用mkfs.xfs</p><blockquote><p>例子</p></blockquote><pre><code>mke2fs -t ext2 -b 1024 -L app -i 10240 -O has_journal -m 5 /dev/sdb1</code></pre><p><code>-i 10240</code> 表示每10240个block，创建一个inode，理论上，文件10240 即10K以下的文件，这样创建inode的方式最合理</p><blockquote><p>e2label  </p></blockquote><p>查看分区的卷标</p><pre><code>&lt;root: ~&gt;# e2label /dev/sdb1app                  #  -L 指明的卷标&lt;root: ~&gt;# e2label /dev/sdb1 app1     #修改设定分区的卷标</code></pre><h3 id="修改文件系统特性"><a href="#修改文件系统特性" class="headerlink" title="修改文件系统特性"></a>修改文件系统特性</h3><blockquote><p>tune2fs [选项] [partition]</p></blockquote><p>选项</p><p><code>-l</code>: 查看超级快的内容</p><p>修改文件系统属性</p><p><code>-j</code> ：ext2–》ext3</p><p><code>-L</code>： 修改卷标</p><p><code>-m</code>：修改预留空间大小百分比  2表示2%</p><p><code>-O [^]</code> ：开启或关闭文件系统特性</p><p><code>-o [^]</code> : 开启或关闭默认挂载特性 例如:acl特性</p><blockquote><p>例子</p></blockquote><pre><code>&lt;root: ~&gt;# tune2fs -l /dev/sdb1                #查看superblock的内容tune2fs 1.41.12 (17-May-2010)Filesystem volume name:   app1Last mounted on:          &lt;not available&gt;Filesystem UUID:          49c26e3e-3d4d-4fcd-ab7c-c2097d5915a8Filesystem magic number:  0xEF53Filesystem revision #:    1 (dynamic)Filesystem features:      has_journal ext_attr resize_inode dir_index filetype sparse_superFilesystem flags:         signed_directory_hash Default mount options:    (none)                 #表示没有启用任何挂载特性...</code></pre><blockquote><p>查看blockgroup的信息</p></blockquote><p> dumpe2fs命令</p><p>用法 dumpe2fs [-h] partition  </p><p><code>-h</code> 同tune2fs -l devices 输出一样      </p><h2 id="挂载文件系统"><a href="#挂载文件系统" class="headerlink" title="挂载文件系统"></a>挂载文件系统</h2><p>将额外文件系统与根文件系统某现存的目录建立起关联关系，进而使得此目录做为其它文件访问入口的行为</p><h3 id="挂载命令的选项"><a href="#挂载命令的选项" class="headerlink" title="挂载命令的选项"></a>挂载命令的选项</h3><p><code>-r</code>  只读文件系统</p><p><code>-w</code>  read and write 读写挂载</p><p><code>-n</code>  默认设备挂载或卸载的操作会同步至/etc/mtab中</p><p><code>-L</code>  指明卷标挂载</p><p><code>-U</code>  指明UUID挂载</p><p><code>-O</code> [OPTION]  指明挂载文件系统是启用的特性</p><p><code>sync async</code>  同步和异步操作</p><p><code>atime noatime</code>  文件或目录在被访问时是否更新时间戳</p><p><code>diratime nodiratime</code>  目录在被访问时是否更新时间戳</p><p><code>remount</code>  重新挂载</p><p><code>acl</code>   支持文件访问控制列表</p><p><code>nodev</code>  禁止在普通目录下创建设备文件  mknod </p><p><code>auto noaotuo</code>  自动挂载</p><p><code>user nouser</code>  是否允许普通用户挂载</p><p><code>--bind</code>  挂载目录</p><p><code>-o loop</code> 挂载有文件系统的文件</p><p><em>mount命令不加任何选项有默认的选项default：rw suid dev exec auto nouser  asnyc relatime</em></p><blockquote><p>注意的地方</p></blockquote><ul><li>mount命令可以挂载目录</li></ul><p>例如</p><pre><code>root: ~&gt;# service autofs statusautomount (pid  1508) is running...&lt;root: ~&gt;# cd /misc/cd&lt;root: cd&gt;# lsCentOS_BuildTag  isolinux                  RPM-GPG-KEY-CentOS-Debug-6EFI              Packages                  RPM-GPG-KEY-CentOS-Security-6EULA             RELEASE-NOTES-en-US.html  RPM-GPG-KEY-CentOS-Testing-6GPL              repodata                  TRANS.TBLimages           RPM-GPG-KEY-CentOS-6&lt;root: cd&gt;# mkdir /var/www/html -p&lt;root: cd&gt;# mount --bind /misc/cd /var/www/html/&lt;root: cd&gt;# ls /var/www/html/CentOS_BuildTag  isolinux                  RPM-GPG-KEY-CentOS-Debug-6EFI              Packages                  RPM-GPG-KEY-CentOS-Security-6EULA             RELEASE-NOTES-en-US.html  RPM-GPG-KEY-CentOS-Testing-6GPL              repodata                  TRANS.TBLimages           RPM-GPG-KEY-CentOS-6</code></pre><p><em>注autofs是一个package，yum安装即可，守护进程为autofs。作用是：当用户cd进/misc/cd/目录后它自己就自动挂载了，可以使用mount命令将此目录挂载到网站根路径下访问，而不需要另外cp，类似给目录创了个硬链接多可一个访问入口。</em></p><ul><li>mount命令挂载具有文件系统的大文件</li></ul><p>例子：</p><pre><code>&lt;root: ~&gt;# dd if=/dev/zero of=test bs=1M count=100&lt;root: ~&gt;# mke2fs test               mke2fs 1.41.12 (17-May-2010)test is not a block special device.Proceed anyway? (y,n) y                    #可以强行格式化&lt;root: ~&gt;# mkdir /mnt/test &lt;root: ~&gt;# mount -o loop test /mnt/test       #挂载文件要用loop 掉用的/dev/loop# 的设备文件</code></pre><p><em>ISO镜像文件也是一个有文件系统<code>iso9660</code>的文件，挂载这种文件就要使用-o loop选项。单centos7中不需要加此选项，系统会自动使用 /dec/loop#文件</em></p><ul><li>禁止更新atime</li></ul><p>在访问量超高的服务器上，例如apache下的网页文件目录，如果启用atime是，会到时磁盘I/O增大，导致系统性能下降</p><blockquote><p>例如</p></blockquote><p>/var/www/html 下如果有单独分区挂载到此目录下应该禁用atime</p><pre><code>mount -o noatime /dev/sdb1 /var/www/html/&lt;root: ~&gt;# mount/dev/mapper/VolGroup-lv_root on / type ext4 (rw)proc on /proc type proc (rw)sysfs on /sys type sysfs (rw)devpts on /dev/pts type devpts (rw,gid=5,mode=620)tmpfs on /dev/shm type tmpfs (rw)/dev/sda1 on /boot type ext4 (rw)none on /proc/sys/fs/binfmt_misc type binfmt_misc (rw)/root/test on /mnt/test type ext2 (rw,loop=/dev/loop0)dev/sdb1 on /var/www/html type ext3 (rw,noatime)</code></pre><p>如果/var/www/html 仅仅是目录的使用 chattr命令</p><pre><code>chattr -A /var/www/html     #禁用目录下的所有文件和目录更新atimechattr -+ i        #对目录加锁无法更改 对root也有效 chattr -+ a        #对目录加锁只允许追加 对root也有效</code></pre><blockquote><p>隐藏挂载</p></blockquote><p>mount 默认挂载的时候默认会将挂载的信息写到<code>/etc/mtab</code> 文件下</p><p>mount -n 表示不写入此文件，在系统启动过程中对根文件系统是只读的，此时不加-n选项，mount命令会往/etc/mtab 中写文件，权限会拒绝，这是后要在启动脚本中mount写入-n选项</p><p>/proc/mounts 中能看到真实的挂载记录</p><blockquote><p>root挂载设备的风险</p></blockquote><p>不要随便挂载未知的设备，要挂的也要使用 -o,noexec,nosuid选项。<br>autofs 进程挂载的方式，默认启用了这两个选项，不用担心。</p><h3 id="卸载设备文件"><a href="#卸载设备文件" class="headerlink" title="卸载设备文件"></a>卸载设备文件</h3><blockquote><p>umount</p></blockquote><p>umount [device] [mountpoint]</p><p>umount卸载可以接挂载点和挂载设备</p><blockquote><p>注意</p></blockquote><p>挂载时会报错</p><pre><code>&lt;root: test&gt;# umount /mnt/test/         umount: /mnt/test: device is busy.    (In some cases useful info about processes that use     the device is found by lsof(8) or fuser(1))</code></pre><p>已经在挂载的目录下卸载会报错，因为自己在使用这个设备，请cd出这个挂载点</p><blockquote><p> 如果有其他用户在使用此设备</p></blockquote><p>lsof [mountpoint]  查看那个用户那个进程在使用这个设备</p><pre><code>&lt;root: ~&gt;# lsof /mnt/test/COMMAND  PID USER   FD   TYPE DEVICE SIZE/OFF NODE NAMEbash    1997  zxs  cwd    DIR    7,0     1024    2 /mnt/test</code></pre><p>fuer -km [mountpoint]  踢掉此用户</p><pre><code>&lt;root: ~&gt;# fuser -km /mnt/test//mnt/test/:           1997c             #已经踢掉此用户了</code></pre><blockquote><p>其他查看此用户的命令</p></blockquote><p><code>df</code> 查看分区(只能查看挂载过的分区)</p><p><code>blkid</code> 查看分区的uuid</p><blockquote><p>判断挂载点和设备是否已经挂载</p></blockquote><p>findmnt 跟设备文件</p><pre><code>&lt;root: ~&gt;#  findmnt /dev/sdb1 ; echo $?    TARGET        SOURCE    FSTYPE OPTIONS/var/www/html /dev/sdb1 ext3   rw,noatime,errors=continue,barrier=1,data=ordered0</code></pre><p>用于脚本中判断设备文件是否已经挂载</p><pre><code>&lt;root: ~&gt;#  findmnt /var/www/html ; echo $?TARGET        SOURCE    FSTYPE OPTIONS/var/www/html /dev/sdb1 ext3   rw,noatime,errors=continue,barrier=1,data=ordered0</code></pre><p>查看或判断目录下是否已经挂载过设备，脚本中有用</p><h3 id="开机自动挂载"><a href="#开机自动挂载" class="headerlink" title="开机自动挂载"></a>开机自动挂载</h3><blockquote><p>配置文件/etc/fstab</p></blockquote><p>格式：</p><pre><code>挂载设备名                挂载点                挂载文件系统         特性     备份次序 开机检查tmpfs                   /dev/shm                tmpfs          defaults        0     0devpts                  /dev/pts                devpts         gid=5,mode=620  0     0sysfs                   /sys                    sysfs         defaults        0     0proc                    /proc                   proc           defaults        0     0/dev/sdb1                /app                    ext4        defaults        0     0</code></pre><p>注意：</p><ul><li><p>设备名最好使用UUID，卷标。应为有些情况下设备名会改变。例如加了一块不同接口类型的硬盘。</p></li><li><p>default：rw suid dev exec auto nouser  asnyc relatime    </p></li><li><p>次文件跟系统启动相关，设置了开机检查的设备，而这个设备出错了，会导致开机无法启动</p></li><li><p>mount -a 命令是读取次文件中的列表，挂载所有自动没有挂载的设备</p></li></ul><blockquote><p>挂载目录到目录，和挂载文件的写法</p></blockquote><pre><code>.../root/test              /mnt/test               ext2    loop,acl        0 0 /misc/cd                /var/www/html           none    bind,noatime    0 0 </code></pre><p><em>目录没有文件系统，要用类型<code>none</code> ，挂载选项必须用<code>bind</code>,挂载有文件系统的挂载特性写<code>loop</code>,iso文件的系统为iso9660</em>    </p><h2 id="管理虚拟内存"><a href="#管理虚拟内存" class="headerlink" title="管理虚拟内存"></a>管理虚拟内存</h2><p>交换分区或者虚拟内存swap分区，存在的意义是当服务器内存，某段时间不够用的时候。使用硬盘上的一段空间，模拟内存使用，而不至于让系统因为，内存不足而出现问题。</p><h3 id="查看内存和交换分区"><a href="#查看内存和交换分区" class="headerlink" title="查看内存和交换分区"></a>查看内存和交换分区</h3><blockquote><p>free</p></blockquote><pre><code>[root@localhost ~]# free          total        used        free      shared  buff/cache   availableMem:         999936       96984      733124        6836      169828      725824Swap:       2097148           0     2097148</code></pre><p>如果系统 swap used的那一列，不是0，而且频繁出于较大的数值，表示系统内存一直出于爆满的状态，这个时候就需要添加物理内存了</p><blockquote><p>创建交换分区</p></blockquote><ol><li>首先创建分区并把修改分区的ID为82，让后同步分区表信息</li><li>mkswap device 交换分区不同于其他分区，格式化命令不一样</li><li>启用交换分区 swapon</li></ol><p>swapon 命令用法</p><pre><code>swap [option] [device]</code></pre><p><code>-a</code> :激活所有的交换分区；</p><p><code>-p PRIORTY</code>：指定优先级，即如果存在多个交换分区，表示那个先用  PRIORITY 表示 0-32767 值越大越优先使用</p><p><code>-s</code> :查看交换分区的优先级等信息</p><pre><code>[root@localhost ~]# swapon -sFilename                Type        Size    Used    Priority/dev/dm-1                               partition    2031612    0    -1/dev/sdc1                               partition    1060252    0    2</code></pre><p><em>小技巧，如果系统某个磁盘快要被用光了，希望腾出大点的空间，可以从swap入手</em></p><blockquote><p>利用文件做交换分区</p></blockquote><p>向windons下的分页文件一样，linux也可以将交换区作为一个文件</p><pre><code>[root@localhost ~]# dd if=/dev/zero of=swapfile bs=1M count=1024    创建一个1G的文件[root@localhost ~]# mkswap swapfile                      格式化为swap分区mkswap: swapfile: warning: don&apos;t erase bootbits sectors   报错没关系    on whole disk. Use -f to force.Setting up swapspace version 1, size = 1048572 KiBno label, UUID=ef9f8966-e5ce-4508-9b4d-147b356e9723[root@localhost ~]# blkid swapfile                      已经看见类型以swap的文件了swapfile: UUID=&quot;ef9f8966-e5ce-4508-9b4d-147b356e9723&quot; TYPE=&quot;swap&quot; </code></pre><p>启用看下能否识别和使用</p><pre><code>[root@localhost ~]# swapon -a swapfile [root@localhost ~]# swapon -sFilename                Type        Size    Used    Priority/dev/dm-1                               partition    2031612    0    -1/dev/sdc1                               partition    1060252    0    2/root/swapfile                          file        1048572    0    -2     #可以看见了[root@localhost ~]# chmod 600 swapfile                #安全起见修改权限</code></pre>]]></content>
    
    <summary type="html">
    
      linxu系统上，简单理解文件和目录的存储方式，从根本上理解软连接和硬链接
    
    </summary>
    
      <category term="linux基础" scheme="http://yoursite.com/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="fdisk" scheme="http://yoursite.com/tags/fdisk/"/>
    
      <category term="parted" scheme="http://yoursite.com/tags/parted/"/>
    
  </entry>
  
  <entry>
    <title>程序包管理</title>
    <link href="http://yoursite.com/2017/08/03/2017-08-03-rpm/"/>
    <id>http://yoursite.com/2017/08/03/2017-08-03-rpm/</id>
    <published>2017-08-02T16:00:00.000Z</published>
    <updated>2017-10-06T08:10:14.067Z</updated>
    
    <content type="html"><![CDATA[<h3 id="程序包管理工具"><a href="#程序包管理工具" class="headerlink" title="程序包管理工具"></a>程序包管理工具</h3><p>redhat 系linux的包管理工具为 rpm，基于rpm 的前端管理工具为 yum 。<br>yum 需要配置yum仓库，可根据repodata数据自动解决软件包依赖关系。<br>.rpm结尾的文件rpm命令就可安装，无法自动解决包的依赖关系. </p><a id="more"></a><h3 id="rpm包管理工具"><a href="#rpm包管理工具" class="headerlink" title="rpm包管理工具"></a>rpm包管理工具</h3><p>rpm 是一个强大的软件包管理器，可以用来构建、安装、查询、校验、升级、卸载单独的软件包。<br>一个包括文件的归档以及用来安装和卸载归档中文件的元数据。<br>元数据包括辅助脚本、文件属性、以及相关的描述性信息。<br>软件包有两种：<br>二进制包，用来封装已经编译好的二进制文件；<br>源代码包，用来封装源代码和要构建二进制包需要的信息。</p><h4 id="rpm获取"><a href="#rpm获取" class="headerlink" title="rpm获取"></a>rpm获取</h4><ul><li>本地光盘</li></ul><p>要用和自己系统版本一样的光盘</p><pre><code>[root: ~]# mount /dev/cdrom /media               #挂载光到/mediamount: block device /dev/sr0 is write-protected, mounting read-only[root: media]# cd /media/Packages/               #包全放在Packages目录下            [root: Packages]# ls httpd*                      httpd-2.2.15-59.el6.centos.x86_64.rpm                   #http主程序包httpd-devel-2.2.15-59.el6.centos.x86_64.rpm            #开发包httpd-manual-2.2.15-59.el6.centos.noarch.rpm            #帮助文档包httpd-tools-2.2.15-59.el6.centos.x86_64.rpm         #工具包</code></pre><ul><li>开源镜像站</li></ul><p>国内各种开源镜像站</p><p>阿里云镜像站 6.9 x86_64为例:</p><p><a href="https://mirrors.aliyun.com/centos/6.9/os/x86_64/Packages/" target="_blank" rel="external">https://mirrors.aliyun.com/centos/6.9/os/x86_64/Packages/</a></p><p>epel源的</p><p><a href="https://mirrors.aliyun.com/epel/7/x86_64/" target="_blank" rel="external">https://mirrors.aliyun.com/epel/7/x86_64/</a></p><p><em>注意：要找跟自己系统和平台架构对应的版本</em></p><ul><li>第三方rpm包搜索网站</li></ul><p><a href="http://rpm.pbone.net/" target="_blank" rel="external">http://rpm.pbone.net/</a></p><p><a href="http://rpmfind.net" target="_blank" rel="external">http://rpmfind.net</a></p><h4 id="rpm命令使用"><a href="#rpm命令使用" class="headerlink" title="rpm命令使用"></a>rpm命令使用</h4><p>rpm软件包的管理功能有：安装、  升级、  卸载、   查询、   校验、  数据库维护。</p><h5 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h5><blockquote><p>用法</p></blockquote><p>rpm {-i|–install} [install-options] PACKAGE_FILE …</p><blockquote><p>简单例子</p></blockquote><pre><code>[root: Packages]# rpm -ivh tree-1.5.3-3.el6.x86_64.rpm Preparing...                ########################################### [100%]   1:tree                   ########################################### [100%]</code></pre><blockquote><p>常用安装选项</p></blockquote><p><code>-i ，--installl</code>  表示安装</p><p><code>-v</code>               表示输出详细信息</p><p><code>-q ，--quiet</code>     表示静默安装</p><p><code>-h</code>               50个# 表示进度条的</p><p><code>--test</code>           测试安装</p><p><code>--nodeps</code>           不检查安装包的依赖性</p><p><code>--nosignature</code>    不检查来源合法性</p><p><code>--noscripts</code>       不执行程序包脚本</p><p><code>--nodigest</code>       不检查包完整</p><p><code>--replacepkgs</code>    删除改错的文件 也可以用 <code>--force</code></p><p><code>--root=/path</code>     安装其他的根目录</p><blockquote><p>例子</p></blockquote><p>如果不小心，删除一些软件中的程序，或者配置文件</p><pre><code>[root: Packages]# rm -rf /usr/bin/tree[root: Packages]# rpm -ivh tree-1.5.3-3.el6.x86_64.rpm Preparing...                ########################################### [100%]package tree-1.5.3-3.el6.x86_64 is already installed          #报错了，已经安装[root: Packages]# rpm -ivh --replacepkgs tree-1.5.3-3.el6.x86_64.rpm Preparing...                ########################################### [100%]   1:tree                   ########################################### [100%]</code></pre><p>可以安装<code>--replaceplgs</code>或者<code>--force</code>重新安装，补回丢失的文件</p><h5 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h5><blockquote><p>用法 </p></blockquote><p>rpm {-U|–upgrade} [install-options] PACKAGE_FILE …</p><p>存在旧版就升级，不存在就安装</p><p>rpm {-F|–upgrade} [install-options] PACKAGE_FILE …</p><p>只升级</p><p><code>--oldpackage</code> 降级安装</p><p><code>--force</code>    强制安装</p><p><em>注意：<br>1 不要对内核做升级操作 linux支持多内核版本并存<br>2 如果某源程序包的配置文件曾被修改过 不会覆盖  而是把新版本的配置文件重命名</em></p><h5 id="卸载"><a href="#卸载" class="headerlink" title="卸载"></a>卸载</h5><blockquote><p>用法</p></blockquote><p>rpm -e PACKAGE_FILE …</p><p><code>--test</code>  测试卸载</p><p><code>--allmatch</code>  匹配所有的版本</p><p><code>--npdeps</code>    忽略依赖关系</p><h5 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h5><blockquote><p>查询</p></blockquote><p><code>-a</code>                所有安装过的包</p><p><code>-f</code>                查指定的文件有那个程序包提供</p><p><code>-p</code>                如果查询没有安装的包，要使用这个选项，后跟包的全名</p><p><code>--whatprovides</code>    查询指定的特性由什么程序包提供</p><p><code>--whatrequires</code>    查询指定的特性被那些程序包依赖</p><p><code>--chengelog</code>       查询包的日志</p><p><code>--provides</code>        查询指定的包提供那些特性</p><p><code>-c</code>                查包提供的配置文件路径</p><p><code>-d</code>                查询包提供的程序文档</p><p><code>-i</code>                查询包的详细信息</p><p><code>-l</code>                列出包所有安装的文件的路径</p><p><code>--scripts</code>         安装时不允许运行脚本</p><p><code>-R</code>                查询指定的包依赖的特性</p><blockquote><p>例子</p></blockquote><p>查询/bin/ls 这个程序是哪个软件包提供的</p><pre><code>[root: Packages]# rpm -qf /bin/lscoreutils-8.4-46.el6.x86_64</code></pre><p>查询myql这个命令是由哪个程序包提供</p><pre><code>[root: Packages]# rpm -q --whatprovides /usr/bin/mysqlmysql-5.1.73-8.el6_8.x86_64</code></pre><p>查询bind包的信息（这个包没有安装）</p><pre><code>[root: Packages]# rpm -qpi bind-9.8.2-0.62.rc1.el6.x86_64.rpm    #要指定包的全名Name        : bind                         Relocations: (not relocatable)Version     : 9.8.2                             Vendor: CentOS</code></pre><p>查询bash包提供那些特性</p><pre><code>[root: Packages]# rpm -q --provides bashconfig(bash) = 4.1.2-48.el6         #这些就是所谓的特性CAPABILITYbash = 4.1.2-48.el6bash(x86-64) = 4.1.2-48.el6</code></pre><h5 id="包的校验"><a href="#包的校验" class="headerlink" title="包的校验"></a>包的校验</h5><blockquote><p>用法</p></blockquote><p>rpm -V [install-options] PACKAGE_FILE …</p><blockquote><p>例子</p></blockquote><pre><code>[root: Packages]# echo &gt;&gt; /usr/bin/tree  #程序后面加一个空行，不影响使用     [root: Packages]# rpm -V tree             S.5....T.    /usr/bin/tree               #不正常就会显示信息</code></pre><p><em>以下出现了几个字母，表示包的属性被修改过没有母的含义如下</em></p><p>S file Size differs</p><p>M Mode differs (includes permissions and file type)</p><p>5 digest (formerly MD5 sum) differs</p><p>D Device major/minor number mismatch</p><p>L readLink(2) path mismatch</p><p>U User ownership differs</p><p>G Group ownership differs</p><p>T mTime differs</p><p>P capabilities differ</p><h5 id="导入gpg密钥"><a href="#导入gpg密钥" class="headerlink" title="导入gpg密钥"></a>导入gpg密钥</h5><p>系统自己的密钥文件在 <code>/etc/pki/rpm-gpg</code> 这个公钥是系统安装时在光盘中copy的<br>光盘的gpgkey文件在光盘的一级目录下名为 <code>RPM-GPG-KEY-CentOS-6</code></p><pre><code>[root: Packages]# rpm -K zsh-4.3.11-4.el6.centos.2.x86_64.rpm   #检查包的来源完整性zsh-4.3.11-4.el6.centos.2.x86_64.rpm: rsa sha1 (md5) pgp md5 OK  rpm --import /etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-6     #导入密钥</code></pre><h5 id="数据库重建"><a href="#数据库重建" class="headerlink" title="数据库重建"></a>数据库重建</h5><p>rpm数据库的路径在 /var/lib/rpm</p><p>rpm包所有查询操作都是基于这个数据库，这个数据库要是坏了就麻烦了，而且所谓的数据库重建，只会帮你重建数据库，而里面的数据则不会修复，要慎重</p><p><code>--initdb</code> :初始化</p><p><code>--rebuilddb</code> 重建已经安装包头的数据库索引目录</p><blockquote><p>例子</p></blockquote><p>看一眼数据库的内容</p><pre><code>[root: rpm]# lsBasenames     __db.004     Name            Pubkeys         Triggernameonflictname  Dirnames     Obsoletename    Requirename__db.001      Filedigests  Packages        Requireversion__db.002      Group        Providename     Sha1header__db.003      Installtid   Provideversion  Sigmd5</code></pre><p>模拟下数据库坏了的情况下如何修复</p><p>注意目录下<code>Packages</code>很关键这个东西丢了，基本完蛋</p><pre><code>[root: rpm]# cp -a Packages /root/[root: rpm]# rm -rf *[root: rpm]# rpm -qa[root: rpm]# rpm -q bashpackage bash is not installed</code></pre><p>现在所有有关于rpm的查询操作都没有效果</p><pre><code>[root: rpm]# rpm -ivh --force /media/Packages/lrzsz-0.12.20-27.1.el6.x86_64.rpm  warning: /media/Packages/lrzsz-0.12.20-27.1.el6.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID c105b9de: NOKEYerror: Failed dependencies:libc.so.6()(64bit) is needed by lrzsz-0.12.20-27.1.el6.x86_64libc.so.6(GLIBC_2.11)(64bit) is needed by lrzsz-0.12.20-27.1.el6.x86_64libc.so.6(GLIBC_2.2.5)(64bit) is needed by lrzsz-0.12.20-27.1.el6.x86_64libc.so.6(GLIBC_2.3)(64bit) is needed by lrzsz-0.12.20-27.1.el6.x86_64libc.so.6(GLIBC_2.3.4)(64bit) is needed by lrzsz-0.12.20-27.1.el6.x86_64libc.so.6(GLIBC_2.4)(64bit) is needed by lrzsz-0.12.20-27.1.el6.x86_64libc.so.6(GLIBC_2.7)(64bit) is needed by lrzsz-0.12.20-27.1.el6.x86_64libnsl.so.1()(64bit) is needed by lrzsz-0.12.20-27.1.el6.x86_64rtld(GNU_HASH) is needed by lrzsz-0.12.20-27.1.el6.x86_64</code></pre><p>安装也出问题了</p><pre><code>[root: rpm]# lsConflictname  __db.002  __db.004  Packages__db.001      __db.003  Name      Providename</code></pre><p>执行了rpm命令后，自己会自动重建数据库，但是没有之前的数据</p><p>修复过程如下</p><pre><code>[root: lib]# rm -rf rpm                   #删除系统自建的[root: lib]# mkdir rpm[root: lib]# cd rpm[root: rpm]# rpm --initdb                  #先初始化                        [root: rpm]# cp -a /root/Packages ./      #在把之前备份的Packages还原回来cp: overwrite `./Packages&apos;? y             #覆盖新的[root: rpm]# rpm --rebuilddb              #重建 如果Packages大的化，会比较慢</code></pre><p>测试下是否修复成功</p><pre><code>[root: rpm]# rpm -qaplymouth-scripts-0.8.3-29.el6.centos.x86_64libreport-filesystem-2.0.9-33.el6.centos.x86_64ca-certificates-2016.2.10-65.4.el6.noarchlibcap-2.16-5.5.el6.x86_64libpcap-1.4.0-4.20130826git2dbcaa1.el6.x86_64</code></pre><p>又回来额，但是前提条件是<code>Packages</code>这个文件不能丢失</p><h3 id="yum前端管理工具"><a href="#yum前端管理工具" class="headerlink" title="yum前端管理工具"></a>yum前端管理工具</h3><p>Yellowdog Update Modifier，rpm的前端程序，可解决软件包相关依赖性，可在多个库之间定位软件包，<br>yum repository: yum repo，存储了众多rpm包，以及包的相关的元数据文件（放置于特定目录repodata下）</p><h4 id="yum客户端配置"><a href="#yum客户端配置" class="headerlink" title="yum客户端配置"></a>yum客户端配置</h4><blockquote><p>配置文件路径在 <code>/etc/yum.repos.d/*.repo</code></p></blockquote><p>centos系统默认的yum客户端文件为<code>CentOS-Base.repo</code> 文件的内容格式为</p><pre><code>[base]                         #定义仓库ID 随便设用中括号就行name=                          #随便取名baseurl=                       #定义仓库路径 指向有repodata的目录就行gpgcheck=                      #定义是否坚持密钥，就是包的来源和完整性检查gpgkey=                        #定义密钥的路径，仓库目录下又有key</code></pre><p>centos系统默认的源指向的是centos.org 官网 服务器在美国，速度你懂得</p><p>手动编辑这个文件也行，执行命令也行，不过命令创建是以仓库URL为name的，比较长</p><pre><code>yum-config-manager --add-repo=https://mirrors.aliyun.com/centos/7/os/x86_64/</code></pre><p>更简单的方法为</p><p>运行wget命令下载，官网的repo文件</p><p>wget -O /etc/yum.repos.d/CentOS-Base.repo <a href="http://mirrors.aliyun.com/repo/Centos-6.repo" target="_blank" rel="external">http://mirrors.aliyun.com/repo/Centos-6.repo</a></p><h4 id="yum命令的使用"><a href="#yum命令的使用" class="headerlink" title="yum命令的使用"></a>yum命令的使用</h4><p>yum有很多子命令</p><blockquote><p>语法</p></blockquote><p>yum [options] [command] [package …]</p><blockquote><p>显示仓库列表</p></blockquote><p><code>yum repolist</code></p><blockquote><p>显示程序包</p></blockquote><p><code>yum list</code></p><p>可以配合grep命令搜索想要的包</p><pre><code>[root: Packages]# yum list | grep kickstartpykickstart.noarch                         1.74.22-1.el6                 base   system-config-kickstart.noarch             2.8.6.6-1.el6                 base   </code></pre><blockquote><p>通用选项</p></blockquote><p><code>--nogpgcheck</code>    禁止gpg check</p><p><code>-y</code> 自动回答为yes</p><p><code>-q</code> 静默安装</p><p><code>--noplugins</code>禁用所有插件    </p><blockquote><p>yum子命令</p></blockquote><p>yum list all</p><p>yum list {installed|available|updates}    </p><p><code>installed</code> 已经安装的</p><p><code>available</code> 可以安装但是未安装的</p><p><code>updates</code>可以更新的</p><blockquote><p>安装软件包</p></blockquote><p><code>installl</code><br><code>reinstall</code></p><blockquote><p>更新软件包</p></blockquote><p><code>yum update</code><br><code>yum downgrade</code></p><blockquote><p>检查更新</p></blockquote><p><code>yum check-update</code></p><blockquote><p>卸载软件包</p></blockquote><p><code>yum remove</code></p><blockquote><p> 查看程序包information</p></blockquote><p><code>yum info</code></p><blockquote><p>清理本地缓存</p></blockquote><p><code>yum clean all</code></p><p>缓存的路径在/var/cache/yum 下</p><blockquote><p>查看指定包依赖的包和包所提供的CAPABILITY</p></blockquote><p><code>yum deplist</code></p><blockquote><p>查看yum事务日志</p></blockquote><p><code>yum history</code></p><p>例子：</p><pre><code>11 | root &lt;root&gt;              | 2017-08-03 00:44 | Install        |    1   10 | root &lt;root&gt;              | 2017-08-03 00:44 | Erase          |    1    9 | root &lt;root&gt;              | 2017-08-02 23:35 | Install        |    1    8 | root &lt;root&gt;              | 2017-08-02 23:35 | Install        |    4    7 | root &lt;root&gt;              | 2017-08-02 23:35 | Install        |    1    6 | root &lt;root&gt;              | 2017-08-02 23:35 | Install        |   12    5 | root &lt;root&gt;              | 2017-08-02 23:35 | Install        |    1    4 | root &lt;root&gt;              | 2017-08-02 23:35 | Install        |    3    3 | root &lt;root&gt;              | 2017-08-02 23:35 | Install        |    2    2 | root &lt;root&gt;              | 2017-08-02 23:35 | Install        |    1    1 | System &lt;unset&gt;           | 2017-07-14 04:22 | Install        |  605   </code></pre><p><em>1号，表示是系统安装时候装的软件包605个</em></p><pre><code>[root: media]# yum history info 6           #查看安装时候的详细信息Loaded plugins: fastestmirror, langpacksTransaction ID : 6Begin time     : Wed Aug  2 23:35:14 2017...</code></pre><p>撤销yum操作为</p><pre><code>yum history undo 6 </code></pre><blockquote><p>搭建私有yum仓库</p></blockquote><p>简单的话直接yum安装 即可，下面为了练习编译安装</p><blockquote><p>安装编译环境</p></blockquote><pre><code>yum groupinstall “development tools” -yyum install prce apr-devel apr-util-devel -y </code></pre><p>编译安装apache</p><pre><code>./configure \--prefix=/usr/local/apache2 \--sysconfdir=/etc/httpd \-enable-so --enable-modules=most \--enable-mods-shared=most \--enable-ssl \--enable-mpms-shared=all \--enable-rewrite \--enable-defale</code></pre><p>添加PATH路径</p><pre><code>echo &apos;export PATH=&quot;/usr/local/apache2/bin:$PATH&quot;&apos; &gt; /etc/profile.d/httpd.sh</code></pre><p>修改配置文件</p><pre><code>vim /etc/httpd/httpd.conf...#DocumentRoot &quot;/usr/local/apache2/htdocs&quot;           # 注释掉中心主机 &lt;Directory &quot;/usr/local/apache2/htdocs&quot;&gt;...# Virtual hosts                                  #Include /etc/httpd/extra/httpd-vhosts.confInclude /etc/httpd/extra/httpd-vhosts.conf           # 启用虚拟主机</code></pre><p>修改虚拟主机的配置</p><pre><code>&lt;VirtualHost *:80&gt;DocumentRoot &quot;/www&quot;ServerName www.zxs.com&lt;Directory  &quot;/www&quot;&gt;    AllowOverride None    Options Indexes    Require all granted&lt;/Directory&gt;&lt;/VirtualHost&gt;</code></pre><p>创建网站目录结构</p><pre><code>mkdir -p /www/centos/{6,7}</code></pre><p>检查apache配置文件</p><pre><code>[root@localhost centos]# httpd -tSyntax OK</code></pre><p>挂载centos6，7光盘，拷贝镜像文件到对应目录下即可<br><em>最好用evetything的光盘软件包比较全</em></p>]]></content>
    
    <summary type="html">
    
      linxu系统上，简单理解文件和目录的存储方式，从根本上理解软连接和硬链接
    
    </summary>
    
      <category term="linux基础" scheme="http://yoursite.com/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="yum" scheme="http://yoursite.com/tags/yum/"/>
    
      <category term="rpm" scheme="http://yoursite.com/tags/rpm/"/>
    
  </entry>
  
  <entry>
    <title>find命令使用总结</title>
    <link href="http://yoursite.com/2017/07/31/2017-07-31-find/"/>
    <id>http://yoursite.com/2017/07/31/2017-07-31-find/</id>
    <published>2017-07-30T16:00:00.000Z</published>
    <updated>2017-10-06T08:10:14.063Z</updated>
    
    <content type="html"><![CDATA[<h3 id="locate命令"><a href="#locate命令" class="headerlink" title="locate命令"></a>locate命令</h3><p>linxu系统查找文件的命令与 localte 和 find ，locate命令依赖于系统上实现创建的索引库，查找速度较快find则是实时查找，查找精确速度较慢，本文主要讲解 find 命令的用法</p><a id="more"></a><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><p>locate命令依赖的数据库文件为 /var/lib/mlocate/mlocate.db`</p><pre><code>Usage locate [OPTIONS]  KEYWORD</code></pre><ul><li>locate 查找不是实时查找，刚创的文件一般找不到，要更新数据库文件</li><li>locate 更新数据库命令为 <code>updatedb</code> 遍历整个操作系统，极其浪费资源，慎用</li><li>查找的关键词，是模糊匹配，且包含路径</li></ul><h4 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h4><ul><li>-i：不区分大小写</li><li>-n #：#表数字，只列举查找出来的#个</li><li>-r：支持正则表达式配置</li></ul><h3 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h3><ul><li>查找速度可能过于缓慢</li><li>实时精确查找</li><li>只能查到用户具备读取和执行权限的目录</li></ul><h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h4><pre><code>find [ 查找路径 ] [ 查找条件 ] [ 处理动作 ]</code></pre><blockquote><p>查找条件有以下几种分类</p></blockquote><h4 id="指定所有层级"><a href="#指定所有层级" class="headerlink" title="指定所有层级"></a>指定所有层级</h4><p><code>-maxdepth level</code> 最大搜索目录的深度</p><p><code>-mindepth level</code> 最小搜索目录的深度</p><p>例如：只查找/etc/目录下的第2层的所有文件</p><pre><code>[root: ~]#  find /etc/ -mindepth 2 -maxdepth 2</code></pre><h4 id="根据文件名和inode"><a href="#根据文件名和inode" class="headerlink" title="根据文件名和inode"></a>根据文件名和inode</h4><p><code>-name</code> FILENAME :按文件名查找，注意是精确匹配，支持glob 文件名通配机制</p><p><code>-iname</code> FILENAME :查找是区分文件的大小写</p><p><code>-inum</code> N : 按inode号查找</p><p><code>-samefile</code> FIELNAME :查找与文件有相同indo号的文件</p><p><code>-links</code> N : 查硬链接数为N的文件</p><p><code>-regex</code> “PARTTERN” :支持正则表达式的查找</p><h4 id="按属主和属组"><a href="#按属主和属组" class="headerlink" title="按属主和属组"></a>按属主和属组</h4><p><code>-user</code>  :按属主查找</p><p><code>-group</code> :按属组查找</p><p><code>-nouser</code> ：查找没有属主的文件</p><p><code>nogroup</code> ：查没有属组的文件</p><p><code>-gid</code> : 按gid</p><p><code>uid</code>  :按uid</p><h4 id="按文件类型"><a href="#按文件类型" class="headerlink" title="按文件类型"></a>按文件类型</h4><pre><code>Useage: -type  TPYE</code></pre><p>TYPE 种类</p><p><code>f</code>    ：普通文件</p><p><code>d</code>    ：目录</p><p><code>b</code>       ：块设备</p><p><code>c</code>    ：字符设备</p><p><code>l</code>    ：符号链接</p><p><code>s</code>    ：套接字</p><p><code>p</code>    ：管道</p><h4 id="与或非条件组合查找"><a href="#与或非条件组合查找" class="headerlink" title="与或非条件组合查找"></a>与或非条件组合查找</h4><p><code>-a</code> 表示与并且   <code>-o</code> 表示或者  <code>!</code>和 <code>-not</code> 表示非</p><p>注意：find命令使用多个条件组合测试时，默认是与的关系，可以省略，如果条件测试时或者的关系 <code>-o</code> 后面还跟了处理动作类似 <code>-ls</code> 要将或的查找条件 <code>\(\)</code> 括号，匹配与后面的处理动作混淆</p><p>例如：查找属主不为root或属主为 daemon 的文件，然后以长格式列举出来</p><pre><code>find  / \(  ! -user root -o -type b \)  -ls</code></pre><p><em>如果不加括号，后面ls的处理动作，只会列举类型为块设备的文件</em></p><h4 id="排除指定目录查找"><a href="#排除指定目录查找" class="headerlink" title="排除指定目录查找"></a>排除指定目录查找</h4><p>例如 ：查找系统中最近10min修改过的文件 （后面有按修改时间查找的用法）</p><pre><code>find / \( -path /proc -o -path /sys \) -prune -o -mmin -10</code></pre><p><em>如果不排除 /proc 和  /sys 两个目录，找出一大堆文件都是进程和系统设备文件的目录，都是在内存中实时变动的找到，也没有意义</em></p><h4 id="按文件大小来查找"><a href="#按文件大小来查找" class="headerlink" title="按文件大小来查找"></a>按文件大小来查找</h4><blockquote><p>按文件大小查找是模糊查找，查找到的精度不一样</p></blockquote><p>Useage: -size [+|-] #UNIT</p><p>常用单位为： K ，M ，G<br>单位不一样查找的精度不一样<br>如查找2M的文件<br>因为系统中几乎不可能大小正好为2M的文件，找到的文件都是 1024K~2048K 之间的</p><p>例如 : 查找/etc下大小为2M的文件</p><pre><code>find /etc/ -size 2M          #找到的都是 1M-2M之间的文件find /etc/ -size +2G          #找到的都是大于2G的文件</code></pre><h4 id="按权限查找"><a href="#按权限查找" class="headerlink" title="按权限查找"></a>按权限查找</h4><p>Usage： -perm [/|-] MODE</p><p><code>-perm 640</code> 表示精确匹配权限为640的文件</p><p><code>-perm /640</code>  这个有点不好理解</p><p>“/640” 可以写成 /rw-r—–   表示9位权限中任何一位满足条件即可，不过这么找没有什么意义稍后举例子解释</p><p><code>-perm  -640</code> </p><p>“-640” 可以写成 /rw-r—– 表示9位的权限必须要都有，只能多不能少，之间是并的关系，如other的权限为0，表示这个权限为不关心了，</p><p>例如：查找/etc目录下所有用户都没有写权限的文件</p><pre><code>find /etc/ ! -perm /222 -ls</code></pre><p><em>这种题目比较绕人，一般写了 “没有什么权限的…” 匹配权限的语法都是有什么权限，要将这种装换成有什么权限的说法，然后整体取反 即相反的说法为:至少有一类用户有写权限 </em></p><p>至少有一类用户有写权限，就是/222 </p><p>命令写法为</p><pre><code>find /etc/ ! -perm /222 -ls</code></pre><h4 id="按时间戳查找"><a href="#按时间戳查找" class="headerlink" title="按时间戳查找"></a>按时间戳查找</h4><blockquote><p>以天为单位</p></blockquote><p><code>-atime</code> [+|-] # :</p><p><code>-mtime</code> [+|-] #：</p><p><code>-ctime</code> [+|-] #：</p><p>系统中没有未来的文件，所以  +7 表示的是，7天之前的  -7表示7天之内的</p><blockquote><p>以分钟表示的方法为</p></blockquote><p><code>-amin</code> ,<code>-mmin</code> ,<code>-cmin</code></p><h4 id="处理动作"><a href="#处理动作" class="headerlink" title="处理动作"></a>处理动作</h4><p><code>-ls</code>  ：即列出详细信息 相当于执行 <code>ls-l</code> 命令</p><p>之前学过管道，这个find的命令，不能找到后直接接管道处理，有点奇葩，要注意  例如：</p><pre><code>find /etc/ ! -perm /222 | ls -l      # 这种写法大错特错find /etc/ ! -perm /222 -ls          # 真确的写法</code></pre><p><code>-delete</code>   ：找到后删除</p><p><code>-fls</code> FILE   ：将找到的文件信息保存到指定的文件中</p><p><code>-ok COMMANDE {} \;</code>  ：将找到的文件交给，COMMAND处理，如果是覆盖，删除类似的操作，需要用户一个一个确认，<br>不想确认请使用 <code>exec</code>替代 <code>ok</code></p><p>注意 <code>{} \;</code> 这个与<code>ok</code> 和 <code>exec</code> 命令是固定写法 “{}” 表示的是前面查找到的结果，写个例子一目了然：</p><p>例：查找当前目录下所有文件然后文件名尾部加上.bak （即重命名）</p><pre><code>touch file{1..100}                             #先touch一堆文件find ./ -name &quot;file*&quot; -exec  mv {} {}.bak \;   # {} 表示找到的文件名     </code></pre><p>这种处理方式应该是找到所有的文件一起交给COMMAND处理，有的COMMAND不支持过多的参数，导致报错，有待验证。</p><p>下面有更好的处理方法</p><h3 id="xargs命令配合使用"><a href="#xargs命令配合使用" class="headerlink" title="xargs命令配合使用"></a>xargs命令配合使用</h3><blockquote><p>在有些命令不接受管道传过来的参数时，xagrs充当中间处理的角色</p></blockquote><p>例如 ：</p><pre><code>echo /etc/sysconfig/ | ls         #他列举的根本不是/etc/sysconfig下的文件echo /etc/sysconfig/ | xargs ls   #这样就正确了</code></pre><blockquote><p>很多命令不接受过多的参数，xargs 处理机制相当于来一个处理一个，而不是管道一次全给后面的命令</p></blockquote><p>例子：</p><pre><code>[root: app]# touch file{1..1000000}-bash: /bin/touch: Argument list too long         #报错了，参数过长[root: app]# echo {1..1000000} | xargs touch      #这样可以执行成功touch: cannot touch `137441&apos;: No space left on device     #由于文件太多把inode用光了</code></pre><p><em>由于find命令一般查找文件的过于繁多，需要配合使用管道和xargs命令，拆分成一个一个的参数流，交给下一个命令处理避免报错</em></p>]]></content>
    
    <summary type="html">
    
      linxu系统上，简单理解文件和目录的存储方式，从根本上理解软连接和硬链接
    
    </summary>
    
      <category term="linux基础" scheme="http://yoursite.com/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="find" scheme="http://yoursite.com/tags/find/"/>
    
  </entry>
  
  <entry>
    <title>bash正则表达式</title>
    <link href="http://yoursite.com/2017/07/30/2017-07-30-regex/"/>
    <id>http://yoursite.com/2017/07/30/2017-07-30-regex/</id>
    <published>2017-07-29T16:00:00.000Z</published>
    <updated>2017-10-06T08:10:14.061Z</updated>
    
    <content type="html"><![CDATA[<h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>正则表达式<code>Regular Expression</code>,通常用来检索、替换那些符合某个模式<code>parttern</code> ，正则表达式的搜索引擎叫 PCRE <code>Perl Compatible Regular Expression</code><br>注意：有些程序支持正则表达式，在编译安装源码的时候有时候会报错没有PCRE，此时安装下这个库就可以了</p><a id="more"></a><blockquote><p>正则表达式有两种</p></blockquote><ul><li><p>基本正则表达式</p></li><li><p>扩展正则表达式</p></li></ul><h3 id="基本正则表达式的元字符"><a href="#基本正则表达式的元字符" class="headerlink" title="基本正则表达式的元字符"></a>基本正则表达式的元字符</h3><p><em>元字符:表示不是代表字符本身而是有特定的含义</em></p><blockquote><p>字符匹配</p></blockquote><pre><code>.                 #匹配单个字符    []                #匹配指定范围内的任意单个字符     [^]                #匹配范围外的任意单个字符[:alumun:]            #字母和数字[:alpha:]             #等价于[a-zA-Z][:space:]            #空白字符[:digit:]             #等价于[0-9][:punct:]             #标点符号</code></pre><blockquote><p>匹配次数</p></blockquote><pre><code>*用于一个字符的后面，表示前面字符出现的次数**                #表示任意次    \?               #0次或1次\+               #至少1次\{n\}              #n次\{n,m\}            #n次和m次之间\{,n\}            #最多n次\{m,\}            #最少M次</code></pre><blockquote><p> 位置锚定</p></blockquote><pre><code>^                         #行首                $                        #行尾^$    ^$                    #空行（中间没有空格）^[[:space:]]*$                    #空白行 （中间可能有空格）\&lt;                              #单词词首\&gt;                              #单词词尾</code></pre><blockquote><p>分组和引用</p></blockquote><pre><code>\(\)            #*用 \(\) 将字符串绑到一起，当做一个字符串处理，\1 \2  ..          #表示引用前面第几个括号的匹配到的内容*\|             #表示或者关系</code></pre><h3 id="用例子来理解正则表达式"><a href="#用例子来理解正则表达式" class="headerlink" title="用例子来理解正则表达式"></a>用例子来理解正则表达式</h3><blockquote><p>匹配 0-255 之间的数字</p></blockquote><p><em>思路</em> 0-255 数字位数不一样，应该按1位数 2位数 3位数来分别表示</p><pre><code>0-9          [0-9]10-99         [1-9][0-9]100-199     1[0-9][0-9]200-249        2[0-4][0-9]250-255        25[0-5]</code></pre><p>用户或的关系串起来就是</p><pre><code>[root: ~]# ifconfig | grep -o &quot;[0-9]\|[1-9][0-9]\|1[0-9][0-9]\|2[0-4][0-9]\|25[0-5]&quot; </code></pre><blockquote><p>精确匹配IP地址</p></blockquote><pre><code>[root: ~]# ifconfig | grep -o &quot;\(\([0-9]\|[1-9][0-9]\|1[0-9][0-9]\|2[0-4][0-9]\)\.\)\{3\}\([0-9]\|[1-9][0-9]\|1[0-9][0-9]\|2[0-4][0-9]\)&quot;</code></pre><blockquote><p>输入一个路径，找出其基名和目录名 （类似<code>basename</code>和<code>dirname</code>）</p></blockquote><ul><li>/etc/sysconfig/network-scripts/ifcfg-eth0</li><li>/etc/rc.d/init.d/</li></ul><p><em>思路：匹配基名，因为不清楚路径到底有多长，而且有的带”/“ ,有的不带。所以从后往前面匹配比较好找规律</em> ，<br>文字表达为：不以”/“结尾的字符串，后面可能带一个”/“</p><p>正则表达式表示为</p><pre><code>echo &quot;/etc/sysconfig/network-scripts/eth0&quot; | grep -o &apos;[^/]\+/\?$&apos;echo &quot;/etc/rc.d/init.d/&quot; | grep -o &apos;[^/]\+/\?$&apos;</code></pre><p><em>思路：匹配目录名，</em></p><p>先看一下<code>dirname</code>命令的显示结果</p><pre><code>[root: ~]# dirname /etc/rc.d/init.d//etc/rc.d[root: ~]# dirname /etc/sysconfig/network-scripts/ifcfg-eth0 /etc/sysconfig/network-scripts</code></pre><p>都是把最后一个“/”后面一部分去掉了。如果最后一个不带“/”，很容易 模式为 “/.*/“ 即可匹配，要让grep的贪婪匹配模式匹配到，最后一个“/” 而且后面要有内容</p><p>正则表达式写法：</p><pre><code>[root: ~]# echo &quot;/etc/rc.d/init.d/&quot; | grep -o &quot;/.*/&quot;/etc/rc.d/init.d/                #直接这样表示会把后面的也取出来[root: ~]# echo &quot;/etc/rc.d/init.d/&quot; | grep -o &quot;/.*/\&lt;&quot;/etc/rc.d/                        #  加个 “\&lt;”  显示出来就完全不一样   </code></pre><p><em>这个 “/&lt;” 词首锚定还有这样的功效，真是不试不知道</em></p>]]></content>
    
    <summary type="html">
    
      linxu系统上，简单理解文件和目录的存储方式，从根本上理解软连接和硬链接
    
    </summary>
    
      <category term="linux基础" scheme="http://yoursite.com/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="regex" scheme="http://yoursite.com/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title>linux acl访问控制</title>
    <link href="http://yoursite.com/2017/07/25/2017-07-25-acl/"/>
    <id>http://yoursite.com/2017/07/25/2017-07-25-acl/</id>
    <published>2017-07-24T16:00:00.000Z</published>
    <updated>2017-10-06T08:10:14.057Z</updated>
    
    <content type="html"><![CDATA[<h2 id="acl访问控制列表的作用"><a href="#acl访问控制列表的作用" class="headerlink" title="acl访问控制列表的作用"></a>acl访问控制列表的作用</h2><p>linxu传统权限，只有owner，group，other 三类，如果对某一个用户，要设定特殊的权限，但又不想改变原有的传统权限位，这时候就要用到ACL</p><a id="more"></a><h3 id="如何设定ACL权限"><a href="#如何设定ACL权限" class="headerlink" title="如何设定ACL权限"></a>如何设定ACL权限</h3><blockquote><p>查看文件或目录的facl权限的命令为<code>getfacl</code> ，比较下传统权限和acl</p></blockquote><pre><code>[root: app]# ll fstab -rw-r--r-- 1 root root 4 Jul 24 13:50 fstab[root: app]# getfacl fstab     # 现在没有设定acl权限，显示的是默认值# file: fstab# owner: root# group: rootuser::rw-            #属主的默认权限group::r--            #属组的默认权限other::r--            #其他用户的默认权限</code></pre><blockquote><p>设定某个特定用户，对该文件有特殊权限</p></blockquote><p><em>上面所示文件 fstab 权限只对root用户有可写权限，设定用户 gentoo 对该文件有写权限</em></p><pre><code>[root: app]# setfacl -m u:gentoo:rw fstab    #设定acl权限[root: app]# getfacl fstab                     # file: fstab                            # owner: root        # group: root            user::rw-            user:gentoo:rw-        #这是自定义的用户对该文件的权限group::r--            mask::rw-            #设定acl后多出来这个，稍后解释other::r--</code></pre><p>切换 gentoo 测试是否有写权限</p><pre><code>[gentoo@localhost app]$ echo abc &gt; fstab </code></pre><blockquote><p>添加某个特定组，对该文件的权限</p></blockquote><pre><code>[root: app]# groupadd admins[root: app]# useradd -g admins centos[root: app]# setfacl -m g:admins:- fstab   #设定admins 组中用户对该文件没有任何权限</code></pre><p>测试</p><pre><code>[centos@localhost ~]$ cat /app/fstab cat: /app/fstab: Permission denied   </code></pre><p><em>admins组中用户对该文件，没有任何权限，但其他用户有可读权限</em></p><p><strong>ACL访问控制列的权限的顺序就是按照列表从上到下匹配</strong></p><p>1 判断用户是否为文件的ower，是就应用默认ower的权限，不会用到acl的自定义列表，不是ower进入第2步</p><p>2 不是ower，查看有没有自定义对该用户的权限，否则进入第3步</p><p>3 查看group是否问文件的group，是的话应用默认group权限，否则进入第4步</p><p>4 查看group中是否有文件中自定义对该group的特殊权限，有就应用特殊权限，否则进入第5步</p><p>5 应用other权限</p><p><strong>ACL可以控制5种用户的权限分别为：</strong></p><ul><li><p>ower</p></li><li><p>自定义users</p></li><li><p>group</p></li><li><p>自定义group</p></li><li><p>other    </p></li></ul><blockquote><p>修改文件默认other 和 group的权限</p></blockquote><pre><code>setfacl -m u::[rwx] fstab    setfacl -m u::[rwx] fstab</code></pre><blockquote><p>清除ACL权限的命令为</p></blockquote><pre><code>setfacl -x u:gentoo  fstab        #后面不用跟权限位setfacl -x g:admins  fstab</code></pre><blockquote><p>mask的作用</p></blockquote><p><em>限定除ower和other之外的最高权限，实际权限后面有注释#effective:r–   看例子:</em></p><pre><code>[root: app]# setfacl -m mask::r  fstab      #设定mask[root: app]# getfacl fstab         # file: fstab# owner: root# group: rootuser::rw-                                             # 默认权限user:gentoo:rw-            #effective:r--     &lt;-- #这个是系统自己注释的，表示实际权限group::r--group:admins:---          mask::r--other::r--[root: app]# ll fstab -rw-r--r--+ 1 root root 4 Jul 24 14:42 fstab</code></pre><p>注意：设定mask权限后，ACL表中 group的默认权限为rw  ，而ls-l命令查看的权限为r  ，因为一旦应用了acl权限后，传统查看权限的命令，显示的是mask位表示的权限，实际应用的是 #effective: 标注的权限</p><p>对该文件重新执行setfacl，命令后会使mask的值发生变化，所以调整mask值属于临时性的 </p><blockquote><p>清除和备份acl的权限和 对目录设定默认acl，递归所有文件acl</p></blockquote><pre><code>[root: app]# tree.├── dir1│   ├── dir2│   │   └── f2│   └── f1├── fstab└── lost+found</code></pre><p>事先创建如上目录结构</p><pre><code>[root: app]# setfacl -m d:g:admins:rw dir1    创建dir1 的默认acl，这个只能对目录创建[root: app]# getfacl dir1/f1        #对已经存在的文件不生效 file: dir1/f1# owner: root# group: rootuser::rw-group::r--other::r--</code></pre><p>查看下新创建的文件和目录是否继承对 dir1 设定的权限</p><pre><code>目录[root: app]# mkdir dir1/dir3               #dir1下创建的目录[root: app]# getfacl dir1/dir3# file: dir1/dir3# owner: root# group: rootuser::rwxgroup::r-xgroup:admins:rw-mask::rwxother::r-xdefault:user::rwxdefault:group::r-x                        #继承了dir1 设定的默认权限default:group:admins:rw-default:mask::rwxdefault:other::r-x文件[root: app]# touch dir1/dir3/f3[root: app]# getfacl dir1/dir3/f3# file: dir1/dir3/f3# owner: root# group: rootuser::rw-group::r-x            #effective:r--group:admins:rw-mask::rw-other::r--</code></pre><p>要想对现有的所有文件和目录递归设置facl权限 使用-R选项</p><pre><code>[root: app]# setfacl -Rm g:admins:--X dir1    #使用大写X，看看有什么不同文件[root: app]# getfacl dir1/f1             对文件没有设置x权限，应为文件有x权限很危险 # file: dir1/f1# owner: root# group: rootuser::rw-group::r--group:admins:---mask::r--other::r--目录[root: app]# getfacl dir1/dir2# file: dir1/dir2# owner: root# group: rootuser::rwxgroup::r-xgroup:admins:--x              对目录却又x权限，x对目录是基本权限  所有X选项在递归的情况下有用mask::r-xother::r-x</code></pre><p>清理目录下所有的权限为</p><pre><code>[root: app]# setfacl -b dir1</code></pre><p>删除目录的默认权限为，</p><pre><code>[root: app]# setfacl -k dir1</code></pre><blockquote><p>备份acl列表和从列表中恢复acl</p></blockquote><pre><code>[root: app]# getfacl fstab &gt; fstab.acl              备份到 fstab.acl[root: app]# setfacl -M fstab.acl dir1/f1           恢复 fstab.acl 到 f1</code></pre><p>注意：利用tar打包工具，或者不加参数的 cp命令，不会保留文件的acl权限，要想保留文件acl权限，此时需要备份acl列表</p>]]></content>
    
    <summary type="html">
    
      linxu系统上，简单理解文件和目录的存储方式，从根本上理解软连接和硬链接
    
    </summary>
    
      <category term="linux基础" scheme="http://yoursite.com/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="setfacl" scheme="http://yoursite.com/tags/setfacl/"/>
    
  </entry>
  
  <entry>
    <title>硬链接与软链接</title>
    <link href="http://yoursite.com/2017/07/20/2017-07-20-link/"/>
    <id>http://yoursite.com/2017/07/20/2017-07-20-link/</id>
    <published>2017-07-19T16:00:00.000Z</published>
    <updated>2017-10-06T08:10:30.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是链接"><a href="#什么是链接" class="headerlink" title="什么是链接"></a>什么是链接</h2><p>你可以将链接简单地理解为 Windows 中常见的快捷方式，Linux 中常用它来解决一些库版本的问题，<br>通常也会将一些目录层次较深的文件链接到一个更易访问的目录中。在这些用途上，我们通常会使用到软链接（也称符号链接）。</p><a id="more"></a><blockquote><p>简单了解文件和目录在文件系统上的存储方式</p></blockquote><p>磁盘分区在被格式化后会被格式化，简单理解就是将空间划分相同大小的块<br>大概为4K，同时建立一张索引表:inode</p><p><img src="http://47.91.157.219/images/inode.png" alt="图1"></p><p><strong>文件inode表的内容大致包括</strong></p><ul><li>mode ：文件类型</li><li>owership  ：属组和属主</li><li>size ：文件大小</li><li>timestamps：时间戳</li><li>inode编号</li><li>数据块指针</li></ul><p><strong>目录的inode的内容</strong></p><ul><li>文件名</li><li>文件inode指针</li></ul><p>例如： cat /etc/issue 系统通过文件系统寻找文件的过程大概为</p><p>系统寻找根目录打开根目录的列表找文件名为issue的inode的记录，在尾部找到文件的inod编号，找到对应文件的inode表，通过尾部的数据块指针，从而从磁盘块中找到对应的数据</p><p><strong>软连接的indode</strong></p><p>软连接是一个文件，与普通文件 a 唯一的不同的是：尾部的指针。普通文件尾部的指针记录了文件所在的数据块编号，而软连接的尾部的指针指向的是里一个文件的inode编号，所以如果源文件被删除，软连接就会找不到数据块无法访问数据而失效</p><p><strong>硬链接的inode表</strong></p><p>硬链接不会创建自己的inode表，而是在原本文件上再增加，一条记录，并有自己的文件名。所以硬链接与被链接的文件inode编号一样，只是有不同的文件名而已，<br>    *注：同一个分区内inode编号是唯一的，不同的分区中的innode表各自有指向自己分区的指针，所以硬链接不可以跨分区创建。</p><blockquote><p>查询inode表的相关命令</p></blockquote><pre><code>[root@localhost ~]# df -i          Filesystem       Inodes IUsed    IFree IUse% Mounted on/dev/sda2      10485760 68733 10417027    1% /devtmpfs          58031   378    57653    1% /devtmpfs             60482     1    60481    1% /dev/shmtmpfs             60482   472    60010    1% /runtmpfs             60482    16    60466    1% /sys/fs/cgroup/dev/sda1        102400   330   102070    1% /boottmpfs             60482     1    60481    1% /run/user/0</code></pre><p><em>查看各个分区inode表的总量和利用情况</em></p><pre><code>[root@localhost ~]# ls -i /root/33574986 2ping.sh  33574979 anaconda-ks.cfg  33574990 fstab</code></pre><p><em>查看目录下inode编号</em></p><pre><code>[root@localhost ~]# stat anaconda-ks.cfg   File: ‘anaconda-ks.cfg’  Size: 1426          Blocks: 8          IO Block: 4096   regular fileDevice: 802h/2050d    Inode: 33574979    Links: 1Access: (0600/-rw-------)  Uid: (    0/    root)   Gid: (    0/    root)Context: system_u:object_r:admin_home_t:s0Access: 2017-07-19 17:41:32.465411463 +0800Modify: 2017-07-14 16:28:59.815991919 +0800Change: 2017-07-14 16:28:59.815991919 +0800 Birth: -</code></pre><p><em>比较详细的方式查看文件的inod表中的信息，和占据磁盘块的大小个数，还有硬链接的个数</em></p><blockquote><p>硬链接和软连接的创建</p></blockquote><p><strong>创建链接的命令非常简单例如：</strong></p><p>Useage：ln [-s] FILENAME  LINKNAME</p><pre><code>[root@localhost app]# ln a.txt b.txt    ##创建a.txt--&gt;b.txt的硬链接[root@localhost app]# ll -itotal 033590001 -rw-r--r--. 2 root root 0 Jul 19 21:33 a.txt33590001 -rw-r--r--. 2 root root 0 Jul 19 21:33 b.txt</code></pre><p><em>可以看到文件的inode编号，一样</em></p><p><strong>创建软连接</strong></p><pre><code>[root@localhost app]# ln -s a.txt c[root@localhost app]# ll clrwxrwxrwx. 1 root root 5 jul 19 21:42 c -&gt; a.txt</code></pre><p><em>注意：用相对路径创建软连接此处有巨坑 </em></p><p>如果在同一个目录下，创建没有什么直接写文件名就好了，不需要写全路径</p><p>如果不在同一个目录下， 如下目录结构</p><pre><code>    /app├── a.txt├── b.txt├── c -&gt; a.txt├── dir1│   └── dir2└── f1</code></pre><p>想要在目录dir2 下创建 f1 文件的软连接  当前目录为/app</p><pre><code>[root@localhost app]# ln -s f1 /app/dir1/dir2/f2</code></pre><p><em>这种写法错了，软连接失效但是系统不会报错</em>  请使用 ls -l 查看</p><p><strong>正确的写法1：</strong></p><pre><code>ln -s /app/f1 /app/dir1/dir2/f3</code></pre><p><em>filename  和  linkname  全用绝对路径</em></p><p><strong>正确的写法2:</strong></p><pre><code>ln -s ../../f1 /app/dir1/dir2/f4</code></pre><p>注：使用相对路径的写法，和一般的相对路径不是一样，不是相对当前工作目录的路径，而是 filename 参考 linkname 的相对路径</p>]]></content>
    
    <summary type="html">
    
      linxu系统上，简单理解文件和目录的存储方式，从根本上理解软连接和硬链接
    
    </summary>
    
      <category term="linux基础" scheme="http://yoursite.com/categories/linux%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="ln" scheme="http://yoursite.com/tags/ln/"/>
    
  </entry>
  
</feed>
